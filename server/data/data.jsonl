{"task_id": "two-sum", "question_id": 1, "difficulty": "Easy", "tags": ["Array", "Hash Table"], "problem_description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n \nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?", "starter_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        d = {}\n        for i, x in enumerate(nums):\n            if (y := target - x) in d:\n                return [d[y], i]\n            d[x] = i\n", "entry_point": "Solution().twoSum", "test": "def check(candidate):\n    assert candidate(nums = [3, 3],target = 6) == [0, 1]\n    assert candidate(nums = [-1, -2, -3, -4],target = -8) == None\n    assert candidate(nums = [1000000000, 1000000000],target = 2000000000) == [0, 1]\n    assert candidate(nums = [1, 5, 7, 9],target = 10) == [0, 3]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],target = 3) == [0, 1]\n    assert candidate(nums = [0, 4, 3, 0],target = 0) == [0, 3]\n    assert candidate(nums = [1000000000, -1000000000, 500000000, -500000000],target = 0) == [0, 1]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],target = 17) == [7, 8]\n    assert candidate(nums = [1, 5, 7, 8],target = 15) == [2, 3]\n    assert candidate(nums = [1000000000, -1000000000],target = 0) == [0, 1]\n    assert candidate(nums = [2, 7, 11, 15],target = 9) == [0, 1]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],target = 19) == [8, 9]\n    assert candidate(nums = [1, 5, 7, 11],target = 16) == [1, 3]\n    assert candidate(nums = [5, 5, 5, 5, 5, 5, 5, 5, 5, 5],target = 10) == [0, 1]\n    assert candidate(nums = [3, 2, 4],target = 6) == [1, 2]\n    assert candidate(nums = [15, 11, 7, 2],target = 9) == [2, 3]\n    assert candidate(nums = [1000000000, -1000000000, 2000000000, -2000000000],target = 0) == [0, 1]\n    assert candidate(nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000],target = 4000) == [18, 20]\n    assert candidate(nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99],target = 100) == [24, 25]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100],target = 199) == [98, 99]\n    assert candidate(nums = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],target = 0) == [4, 6]\n    assert candidate(nums = [-10, -20, -30, -40, -50, -60, -70, -80, -90, -100],target = -150) == [6, 7]\n    assert candidate(nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20],target = -39) == [18, 19]\n    assert candidate(nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119],target = 110) == [26, 28]\n    assert candidate(nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],target = 1100) == [4, 5]\n    assert candidate(nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39],target = 70) == [16, 18]\n    assert candidate(nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],target = 3) == [18, 19]\n    assert candidate(nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500],target = 3000) == [13, 15]\n    assert candidate(nums = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000],target = 30000) == [13, 15]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],target = 39) == [18, 19]\n    assert candidate(nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99],target = 99) == [49, 50]\n    assert candidate(nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500],target = 900) == [43, 45]\n    assert candidate(nums = [-1000000000, -2000000000, -3000000000, -4000000000, -5000000000, -6000000000, -7000000000, -8000000000, -9000000000, -10000000000],target = -15000000000) == [6, 7]\n    assert candidate(nums = [23, 8, 15, 37, 48, 5, 21, 7, 40, 6],target = 33) == None\n    assert candidate(nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200],target = 390) == [18, 19]\n    assert candidate(nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000],target = 1500) == [6, 7]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],target = 21) == [9, 10]\n    assert candidate(nums = [2, 5, 1, 9, 3, 8, 7, 6, 4, 0],target = 17) == [3, 5]\n    assert candidate(nums = [1000000000, -1000000000, 500000000, 500000000],target = 0) == [0, 1]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],target = 29) == [13, 14]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],target = 38) == [17, 19]\n    assert candidate(nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39],target = 78) == None\n    assert candidate(nums = [-1000000000, 1000000000, 500000000, -500000000],target = 0) == [0, 1]\n    assert candidate(nums = [1000000000, 999999999, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],target = 1999999999) == [0, 1]\n    assert candidate(nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200],target = 300) == [13, 15]\n    assert candidate(nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59],target = 100) == [24, 25]\n    assert candidate(nums = [5, 12, 7, 3, 9, 14, 10, 23, 1, 11],target = 22) == [1, 6]\n    assert candidate(nums = [-3, 4, 3, 90, -11, 23, -5, 67, 100, -45, 89],target = 53) == None\n    assert candidate(nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, -82, -83, -84, -85, -86, -87, -88, -89, -90, -91, -92, -93, -94, -95, -96, -97, -98, -99, -100],target = -199) == [98, 99]\n    assert candidate(nums = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],target = 1) == [0, 1]\n    assert candidate(nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],target = 3) == [23, 24]\n    assert candidate(nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710, 720, 730, 740, 750, 760, 770, 780, 790, 800, 810, 820, 830, 840, 850, 860, 870, 880, 890, 900, 910, 920, 930, 940, 950, 960, 970, 980, 990, 1000],target = 1990) == [98, 99]\n    assert candidate(nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],target = 59) == [29, 30]\n    assert candidate(nums = [123456789, 987654321, 456789123, 321987654, 654321987, 789123456],target = 1111111110) == [0, 1]\n    assert candidate(nums = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],target = 0) == [0, 1]\n    assert candidate(nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10],target = -11) == [4, 5]\n    assert candidate(nums = [999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992],target = 1999999997) == [0, 1]\n    assert candidate(nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10],target = -15) == [6, 7]\n    assert candidate(nums = [1000000000, -1000000000, 500000000, 500000000, -500000000, -500000000, 1, 2, 3, 4],target = 0) == [0, 1]\n    assert candidate(nums = [1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000],target = 2000000000) == [0, 1]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150],target = 299) == [148, 149]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],target = 59) == [28, 29]\n    assert candidate(nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20],target = -31) == [14, 15]\n    assert candidate(nums = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000, 21000, 22000, 23000, 24000, 25000, 26000, 27000, 28000, 29000, 30000],target = 60000) == None\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],target = 39) == [18, 19]\n    assert candidate(nums = [1000000000, -500000000, 2000000000, -1000000000, 0, 500000000],target = 1000000000) == [2, 3]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50],target = 99) == [48, 49]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],target = 49) == [23, 24]\n    assert candidate(nums = [999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992, 999999991, 999999990],target = 1999999989) == [4, 5]\n    assert candidate(nums = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512],target = 513) == [0, 9]\n    assert candidate(nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10],target = -18) == [7, 9]\n    assert candidate(nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500],target = 1300) == [5, 6]\n    assert candidate(nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10],target = -17) == [7, 8]\n    assert candidate(nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000],target = 1900) == [8, 9]\n    assert candidate(nums = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],target = 0) == [0, 1]\n    assert candidate(nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39],target = 79) == None\n    assert candidate(nums = [1000000000, 2000000000, 3000000000, 4000000000, 5000000000, 6000000000, 7000000000, 8000000000, 9000000000, 10000000000],target = 30000000000) == None\n    assert candidate(nums = [-3, -1, 0, 2, 5, 7, 8, 10],target = 4) == [1, 4]\n    assert candidate(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50],target = 100) == None\n    assert candidate(nums = [29, 37, 10, 55, 44, 3, 67, 90, 11, 38, 2, 9, 100, 34, 65, 23, 89, 12, 33, 22],target = 62) == [0, 18]\n", "input_output": [{"input": "nums = [3,3], target = 6", "output": "[0, 1]"}, {"input": "nums = [-1,-2,-3,-4], target = -8", "output": "None"}, {"input": "nums = [1000000000, 1000000000], target = 2000000000", "output": "[0, 1]"}, {"input": "nums = [1,5,7,9], target = 10", "output": "[0, 3]"}, {"input": "nums = [1,2,3,4,5,6,7,8,9,10], target = 3", "output": "[0, 1]"}, {"input": "nums = [0,4,3,0], target = 0", "output": "[0, 3]"}, {"input": "nums = [1000000000, -1000000000, 500000000, -500000000], target = 0", "output": "[0, 1]"}, {"input": "nums = [1,2,3,4,5,6,7,8,9,10], target = 17", "output": "[7, 8]"}, {"input": "nums = [1,5,7,8], target = 15", "output": "[2, 3]"}, {"input": "nums = [1000000000, -1000000000], target = 0", "output": "[0, 1]"}, {"input": "nums = [2,7,11,15], target = 9", "output": "[0, 1]"}, {"input": "nums = [1,2,3,4,5,6,7,8,9,10], target = 19", "output": "[8, 9]"}, {"input": "nums = [1,5,7,11], target = 16", "output": "[1, 3]"}, {"input": "nums = [5,5,5,5,5,5,5,5,5,5], target = 10", "output": "[0, 1]"}, {"input": "nums = [3,2,4], target = 6", "output": "[1, 2]"}, {"input": "nums = [15,11,7,2], target = 9", "output": "[2, 3]"}, {"input": "nums = [1000000000,-1000000000,2000000000,-2000000000], target = 0", "output": "[0, 1]"}, {"input": "nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000], target = 4000", "output": "[18, 20]"}, {"input": "nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99], target = 100", "output": "[24, 25]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100], target = 199", "output": "[98, 99]"}, {"input": "nums = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5], target = 0", "output": "[4, 6]"}, {"input": "nums = [-10, -20, -30, -40, -50, -60, -70, -80, -90, -100], target = -150", "output": "[6, 7]"}, {"input": "nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20], target = -39", "output": "[18, 19]"}, {"input": "nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119], target = 110", "output": "[26, 28]"}, {"input": "nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 1100", "output": "[4, 5]"}, {"input": "nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39], target = 70", "output": "[16, 18]"}, {"input": "nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2], target = 3", "output": "[18, 19]"}, {"input": "nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500], target = 3000", "output": "[13, 15]"}, {"input": "nums = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000], target = 30000", "output": "[13, 15]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], target = 39", "output": "[18, 19]"}, {"input": "nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], target = 99", "output": "[49, 50]"}, {"input": "nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500], target = 900", "output": "[43, 45]"}, {"input": "nums = [-1000000000, -2000000000, -3000000000, -4000000000, -5000000000, -6000000000, -7000000000, -8000000000, -9000000000, -10000000000], target = -15000000000", "output": "[6, 7]"}, {"input": "nums = [23, 8, 15, 37, 48, 5, 21, 7, 40, 6], target = 33", "output": "None"}, {"input": "nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200], target = 390", "output": "[18, 19]"}, {"input": "nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000], target = 1500", "output": "[6, 7]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], target = 21", "output": "[9, 10]"}, {"input": "nums = [2, 5, 1, 9, 3, 8, 7, 6, 4, 0], target = 17", "output": "[3, 5]"}, {"input": "nums = [1000000000, -1000000000, 500000000, 500000000], target = 0", "output": "[0, 1]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], target = 29", "output": "[13, 14]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], target = 38", "output": "[17, 19]"}, {"input": "nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39], target = 78", "output": "None"}, {"input": "nums = [-1000000000, 1000000000, 500000000, -500000000], target = 0", "output": "[0, 1]"}, {"input": "nums = [1000000000, 999999999, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 1999999999", "output": "[0, 1]"}, {"input": "nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200], target = 300", "output": "[13, 15]"}, {"input": "nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59], target = 100", "output": "[24, 25]"}, {"input": "nums = [5, 12, 7, 3, 9, 14, 10, 23, 1, 11], target = 22", "output": "[1, 6]"}, {"input": "nums = [-3, 4, 3, 90, -11, 23, -5, 67, 100, -45, 89], target = 53", "output": "None"}, {"input": "nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, -82, -83, -84, -85, -86, -87, -88, -89, -90, -91, -92, -93, -94, -95, -96, -97, -98, -99, -100], target = -199", "output": "[98, 99]"}, {"input": "nums = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], target = 1", "output": "[0, 1]"}, {"input": "nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2], target = 3", "output": "[23, 24]"}, {"input": "nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710, 720, 730, 740, 750, 760, 770, 780, 790, 800, 810, 820, 830, 840, 850, 860, 870, 880, 890, 900, 910, 920, 930, 940, 950, 960, 970, 980, 990, 1000], target = 1990", "output": "[98, 99]"}, {"input": "nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], target = 59", "output": "[29, 30]"}, {"input": "nums = [123456789, 987654321, 456789123, 321987654, 654321987, 789123456], target = 1111111110", "output": "[0, 1]"}, {"input": "nums = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], target = 0", "output": "[0, 1]"}, {"input": "nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10], target = -11", "output": "[4, 5]"}, {"input": "nums = [999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992], target = 1999999997", "output": "[0, 1]"}, {"input": "nums = [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10], target = -15", "output": "[6, 7]"}, {"input": "nums = [1000000000, -1000000000, 500000000, 500000000, -500000000, -500000000, 1, 2, 3, 4], target = 0", "output": "[0, 1]"}, {"input": "nums = [1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000], target = 2000000000", "output": "[0, 1]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150], target = 299", "output": "[148, 149]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], target = 59", "output": "[28, 29]"}, {"input": "nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20], target = -31", "output": "[14, 15]"}, {"input": "nums = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000, 20000, 21000, 22000, 23000, 24000, 25000, 26000, 27000, 28000, 29000, 30000], target = 60000", "output": "None"}, {"input": "nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], target = 39", "output": "[18, 19]"}, {"input": "nums = [1000000000, -500000000, 2000000000, -1000000000, 0, 500000000], target = 1000000000", "output": "[2, 3]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], target = 99", "output": "[48, 49]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], target = 49", "output": "[23, 24]"}, {"input": "nums = [999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992, 999999991, 999999990], target = 1999999989", "output": "[4, 5]"}, {"input": "nums = [1,2,4,8,16,32,64,128,256,512], target = 513", "output": "[0, 9]"}, {"input": "nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10], target = -18", "output": "[7, 9]"}, {"input": "nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500], target = 1300", "output": "[5, 6]"}, {"input": "nums = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10], target = -17", "output": "[7, 8]"}, {"input": "nums = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000], target = 1900", "output": "[8, 9]"}, {"input": "nums = [0,0,0,0,0,0,0,0,0,0], target = 0", "output": "[0, 1]"}, {"input": "nums = [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39], target = 79", "output": "None"}, {"input": "nums = [1000000000, 2000000000, 3000000000, 4000000000, 5000000000, 6000000000, 7000000000, 8000000000, 9000000000, 10000000000], target = 30000000000", "output": "None"}, {"input": "nums = [-3, -1, 0, 2, 5, 7, 8, 10], target = 4", "output": "[1, 4]"}, {"input": "nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], target = 100", "output": "None"}, {"input": "nums = [29, 37, 10, 55, 44, 3, 67, 90, 11, 38, 2, 9, 100, 34, 65, 23, 89, 12, 33, 22], target = 62", "output": "[0, 18]"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n \nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "To solve this problem efficiently, we can use a hash map (dictionary in Python) to store the numbers we have seen so far and their indices. This allows us to check in constant time whether the complement of the current number (i.e., `target - current_number`) has already been encountered. This approach reduces the time complexity from O(n^2) to O(n).\n\nHere's the implementation:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # Create a dictionary to store the numbers and their indices\n        num_to_index = {}\n        \n        # Iterate over the list of numbers\n        for index, num in enumerate(nums):\n            # Calculate the complement\n            complement = target - num\n            \n            # Check if the complement is already in the dictionary\n            if complement in num_to_index:\n                # If found, return the indices of the complement and the current number\n                return [num_to_index[complement], index]\n            \n            # Otherwise, add the current number and its index to the dictionary\n            num_to_index[num] = index\n```\n\n### Explanation:\n1. We initialize an empty dictionary `num_to_index` to store numbers and their indices as we iterate through the list.\n2. For each number in the list, we calculate its complement with respect to the target.\n3. We check if this complement is already in the dictionary:\n   - If it is, we have found the two numbers that add up to the target, and we return their indices.\n   - If it is not, we add the current number and its index to the dictionary.\n4. This approach ensures that we only pass through the list once, achieving a time complexity of O(n)."}
{"task_id": "add-two-numbers", "question_id": 2, "difficulty": "Medium", "tags": ["Recursion", "Linked List", "Math"], "problem_description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n \nExample 1:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n \nConstraints:\n\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\n", "starter_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        ", "estimated_date": "2015-08-07", "prompt": "import heapq\nimport itertools\nfrom sortedcontainers import SortedList\nimport random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummy = ListNode()\n        carry, curr = 0, dummy\n        while l1 or l2 or carry:\n            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            carry, val = divmod(s, 10)\n            curr.next = ListNode(val)\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummy.next\n", "entry_point": "Solution().addTwoNumbers", "test": "def check(candidate):\n    assert is_same_list(candidate(l1 = list_node([9, 8, 7]),l2 = list_node([1, 2, 3])), list_node([0, 1, 1, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),l2 = list_node([5, 6, 4])), list_node([6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),l2 = list_node([5, 6, 4])), list_node([6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([2, 4, 3]),l2 = list_node([5, 6, 4, 1])), list_node([7, 0, 8, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 2, 3, 4, 5]),l2 = list_node([9, 8, 7, 6, 5])), list_node([0, 1, 1, 1, 1, 1]))\n    assert is_same_list(candidate(l1 = list_node([1]),l2 = list_node([9, 9, 9, 9, 9, 9, 9, 9, 9, 9])), list_node([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([5, 5, 5]),l2 = list_node([5, 5, 5, 5, 5])), list_node([0, 1, 1, 6, 5]))\n    assert is_same_list(candidate(l1 = list_node([9, 9, 9, 9, 9, 9, 9]),l2 = list_node([9, 9, 9, 9])), list_node([8, 9, 9, 9, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([9, 9, 9, 9, 9, 9, 9, 9, 9, 9]),l2 = list_node([1])), list_node([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1]),l2 = list_node([9, 9])), list_node([0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0]),l2 = list_node([9, 9, 9, 9])), list_node([0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([9, 8, 7, 6, 5, 4, 3, 2, 1]),l2 = list_node([1, 2, 3, 4, 5, 6, 7, 8, 9])), list_node([0, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 8, 9]),l2 = list_node([0, 0, 9])), list_node([1, 8, 8, 1]))\n    assert is_same_list(candidate(l1 = list_node([2, 4, 3]),l2 = list_node([5, 6, 4])), list_node([7, 0, 8]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),l2 = list_node([5, 6, 4])), list_node([6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([2, 4, 6]),l2 = list_node([1, 3, 5])), list_node([3, 7, 1, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 1, 1]),l2 = list_node([9, 9, 9])), list_node([0, 1, 1, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 8]),l2 = list_node([0])), list_node([1, 8]))\n    assert is_same_list(candidate(l1 = list_node([1, 8]),l2 = list_node([0])), list_node([1, 8]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),l2 = list_node([4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5])), list_node([5, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]))\n    assert is_same_list(candidate(l1 = list_node([1, 8, 9]),l2 = list_node([9, 1])), list_node([0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([7, 2, 4, 3]),l2 = list_node([5, 6, 4])), list_node([2, 9, 8, 3]))\n    assert is_same_list(candidate(l1 = list_node([1]),l2 = list_node([1, 2, 3, 4, 5])), list_node([2, 2, 3, 4, 5]))\n    assert is_same_list(candidate(l1 = list_node([1]),l2 = list_node([9, 9, 9, 9, 9, 9, 9, 9, 9])), list_node([0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([6, 4, 5]),l2 = list_node([0, 4, 5])), list_node([6, 8, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([5]),l2 = list_node([5])), list_node([0, 1]))\n    assert is_same_list(candidate(l1 = list_node([7, 2, 4, 3]),l2 = list_node([5, 6, 4, 2])), list_node([2, 9, 8, 5]))\n    assert is_same_list(candidate(l1 = list_node([1, 2]),l2 = list_node([3, 4, 5, 6])), list_node([4, 6, 5, 6]))\n    assert is_same_list(candidate(l1 = list_node([9, 9, 9]),l2 = list_node([1])), list_node([0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([9, 9]),l2 = list_node([1])), list_node([0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1]),l2 = list_node([9, 9, 9, 9, 9, 9, 9, 9])), list_node([0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1]),l2 = list_node([9])), list_node([0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 2, 3]),l2 = list_node([9, 8, 7])), list_node([0, 1, 1, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 2, 3]),l2 = list_node([7, 8, 9])), list_node([8, 0, 3, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),l2 = list_node([5, 6, 4])), list_node([6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),l2 = list_node([9, 9, 9, 9, 9, 9, 9, 9, 9, 9])), list_node([0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 2, 3]),l2 = list_node([4, 5, 6])), list_node([5, 7, 9]))\n    assert is_same_list(candidate(l1 = list_node([1, 2, 3, 4, 5]),l2 = list_node([5, 4, 3, 2, 1])), list_node([6, 6, 6, 6, 6]))\n    assert is_same_list(candidate(l1 = list_node([0, 0, 1]),l2 = list_node([0, 0, 1])), list_node([0, 0, 2]))\n    assert is_same_list(candidate(l1 = list_node([9, 9]),l2 = list_node([1, 1, 1])), list_node([0, 1, 2]))\n    assert is_same_list(candidate(l1 = list_node([6, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),l2 = list_node([3, 4, 2])), list_node([9, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([9]),l2 = list_node([1])), list_node([0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]),l2 = list_node([1])), list_node([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]))\n    assert is_same_list(candidate(l1 = list_node([1, 2, 3]),l2 = list_node([4, 5, 6])), list_node([5, 7, 9]))\n    assert is_same_list(candidate(l1 = list_node([1, 8, 9]),l2 = list_node([2, 5, 8])), list_node([3, 3, 8, 1]))\n    assert is_same_list(candidate(l1 = list_node([9, 9, 9, 9, 9, 9, 9]),l2 = list_node([9, 9, 9, 9])), list_node([8, 9, 9, 9, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([3, 2, 1]),l2 = list_node([9, 8, 7])), list_node([2, 1, 9]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),l2 = list_node([5, 6, 4])), list_node([6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),l2 = list_node([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6])), list_node([6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7]))\n    assert is_same_list(candidate(l1 = list_node([1, 2, 3, 4, 5]),l2 = list_node([1, 2, 3, 4, 5])), list_node([2, 4, 6, 8, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([0]),l2 = list_node([0])), list_node([0]))\n    assert is_same_list(candidate(l1 = list_node([2, 4, 9]),l2 = list_node([5, 6, 4, 9])), list_node([7, 0, 4, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([2, 4, 3]),l2 = list_node([5, 6, 4])), list_node([7, 0, 8]))\n    assert is_same_list(candidate(l1 = list_node([2, 4, 3, 2, 5, 5, 5]),l2 = list_node([5, 6, 4])), list_node([7, 0, 8, 2, 5, 5, 5]))\n    assert is_same_list(candidate(l1 = list_node([1, 0, 0, 0, 0]),l2 = list_node([9, 9, 9, 9, 9])), list_node([0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([2, 4, 6, 8]),l2 = list_node([1, 3, 5, 7])), list_node([3, 7, 1, 6, 1]))\n    assert is_same_list(candidate(l1 = list_node([9]),l2 = list_node([1, 9, 9, 9, 9, 9, 9, 9, 9, 9])), list_node([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]))\n    assert is_same_list(candidate(l1 = list_node([0, 1]),l2 = list_node([0, 1])), list_node([0, 2]))\n    assert is_same_list(candidate(l1 = list_node([7, 1, 6]),l2 = list_node([5, 9, 2])), list_node([2, 1, 9]))\n", "input_output": [{"input": "l1 = [9,8,7], l2 = [1,2,3]", "output": "[0, 1, 1, 1]"}, {"input": "l1 = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], l2 = [5,6,4]", "output": "[6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"}, {"input": "l1 = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], l2 = [5,6,4]", "output": "[6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [2,4,3], l2 = [5,6,4,1]", "output": "[7, 0, 8, 1]"}, {"input": "l1 = [1,2,3,4,5], l2 = [9,8,7,6,5]", "output": "[0, 1, 1, 1, 1, 1]"}, {"input": "l1 = [1], l2 = [9,9,9,9,9,9,9,9,9,9]", "output": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [5,5,5], l2 = [5,5,5,5,5]", "output": "[0, 1, 1, 6, 5]"}, {"input": "l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]", "output": "[8, 9, 9, 9, 0, 0, 0, 1]"}, {"input": "l1 = [9,9,9,9,9,9,9,9,9,9], l2 = [1]", "output": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [1], l2 = [9,9]", "output": "[0, 0, 1]"}, {"input": "l1 = [1,0,0,0,0], l2 = [9,9,9,9]", "output": "[0, 0, 0, 0, 1]"}, {"input": "l1 = [9,8,7,6,5,4,3,2,1], l2 = [1,2,3,4,5,6,7,8,9]", "output": "[0, 1, 1, 1, 1, 1, 1, 1, 1, 1]"}, {"input": "l1 = [1,8,9], l2 = [0,0,9]", "output": "[1, 8, 8, 1]"}, {"input": "l1 = [2, 4, 3], l2 = [5, 6, 4]", "output": "[7, 0, 8]"}, {"input": "l1 = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], l2 = [5,6,4]", "output": "[6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [2,4,6], l2 = [1,3,5]", "output": "[3, 7, 1, 1]"}, {"input": "l1 = [1,1,1], l2 = [9,9,9]", "output": "[0, 1, 1, 1]"}, {"input": "l1 = [1, 8], l2 = [0]", "output": "[1, 8]"}, {"input": "l1 = [1,8], l2 = [0]", "output": "[1, 8]"}, {"input": "l1 = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], l2 = [4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5]", "output": "[5, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]"}, {"input": "l1 = [1,8,9], l2 = [9,1]", "output": "[0, 0, 0, 1]"}, {"input": "l1 = [7,2,4,3], l2 = [5,6,4]", "output": "[2, 9, 8, 3]"}, {"input": "l1 = [1], l2 = [1,2,3,4,5]", "output": "[2, 2, 3, 4, 5]"}, {"input": "l1 = [1], l2 = [9,9,9,9,9,9,9,9,9]", "output": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [6,4,5], l2 = [0,4,5]", "output": "[6, 8, 0, 1]"}, {"input": "l1 = [5], l2 = [5]", "output": "[0, 1]"}, {"input": "l1 = [7,2,4,3], l2 = [5,6,4,2]", "output": "[2, 9, 8, 5]"}, {"input": "l1 = [1,2], l2 = [3,4,5,6]", "output": "[4, 6, 5, 6]"}, {"input": "l1 = [9,9,9], l2 = [1]", "output": "[0, 0, 0, 1]"}, {"input": "l1 = [9,9], l2 = [1]", "output": "[0, 0, 1]"}, {"input": "l1 = [1], l2 = [9,9,9,9,9,9,9,9]", "output": "[0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [1], l2 = [9]", "output": "[0, 1]"}, {"input": "l1 = [1,2,3], l2 = [9,8,7]", "output": "[0, 1, 1, 1]"}, {"input": "l1 = [1,2,3], l2 = [7,8,9]", "output": "[8, 0, 3, 1]"}, {"input": "l1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], l2 = [5, 6, 4]", "output": "[6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [1,1,1,1,1,1,1,1,1,1], l2 = [9,9,9,9,9,9,9,9,9,9]", "output": "[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"}, {"input": "l1 = [1,2,3], l2 = [4,5,6]", "output": "[5, 7, 9]"}, {"input": "l1 = [1,2,3,4,5], l2 = [5,4,3,2,1]", "output": "[6, 6, 6, 6, 6]"}, {"input": "l1 = [0,0,1], l2 = [0,0,1]", "output": "[0, 0, 2]"}, {"input": "l1 = [9,9], l2 = [1,1,1]", "output": "[0, 1, 2]"}, {"input": "l1 = [6,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], l2 = [3,4,2]", "output": "[9, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [9], l2 = [1]", "output": "[0, 1]"}, {"input": "l1 = [1,0,0,0,0,0,0,0,0,0], l2 = [1]", "output": "[2, 0, 0, 0, 0, 0, 0, 0, 0, 0]"}, {"input": "l1 = [1, 2, 3], l2 = [4, 5, 6]", "output": "[5, 7, 9]"}, {"input": "l1 = [1,8,9], l2 = [2,5,8]", "output": "[3, 3, 8, 1]"}, {"input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]", "output": "[8, 9, 9, 9, 0, 0, 0, 1]"}, {"input": "l1 = [3,2,1], l2 = [9,8,7]", "output": "[2, 1, 9]"}, {"input": "l1 = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], l2 = [5,6,4]", "output": "[6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], l2 = [5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6]", "output": "[6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7]"}, {"input": "l1 = [1,2,3,4,5], l2 = [1,2,3,4,5]", "output": "[2, 4, 6, 8, 0, 1]"}, {"input": "l1 = [0], l2 = [0]", "output": "[0]"}, {"input": "l1 = [2,4,9], l2 = [5,6,4,9]", "output": "[7, 0, 4, 0, 1]"}, {"input": "l1 = [2,4,3], l2 = [5,6,4]", "output": "[7, 0, 8]"}, {"input": "l1 = [2,4,3,2,5,5,5], l2 = [5,6,4]", "output": "[7, 0, 8, 2, 5, 5, 5]"}, {"input": "l1 = [1,0,0,0,0], l2 = [9,9,9,9,9]", "output": "[0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [2,4,6,8], l2 = [1,3,5,7]", "output": "[3, 7, 1, 6, 1]"}, {"input": "l1 = [9], l2 = [1,9,9,9,9,9,9,9,9,9]", "output": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]"}, {"input": "l1 = [0,1], l2 = [0,1]", "output": "[0, 2]"}, {"input": "l1 = [7,1,6], l2 = [5,9,2]", "output": "[2, 1, 9]"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n \nExample 1:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n \nConstraints:\n\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n        \n        while l1 is not None or l2 is not None or carry != 0:\n            val1 = l1.val if l1 is not None else 0\n            val2 = l2.val if l2 is not None else 0\n            carry, out = divmod(val1 + val2 + carry, 10)\n            \n            current.next = ListNode(out)\n            current = current.next\n            \n            if l1 is not None:\n                l1 = l1.next\n            if l2 is not None:\n                l2 = l2.next\n        \n        return dummy_head.next\n```\n\nThis solution correctly implements the addition of two numbers represented by linked lists. It handles the carry-over for sums greater than 9 and continues processing until all digits and the final carry are processed. The `dummy_head` is used to simplify the code by avoiding special cases for the head of the result list."}
{"task_id": "longest-substring-without-repeating-characters", "question_id": 3, "difficulty": "Medium", "tags": ["Hash Table", "String", "Sliding Window"], "problem_description": "Given a string s, find the length of the longest substring without repeating characters.\n \nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n \nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n\n", "starter_code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:", "estimated_date": "2015-08-07", "prompt": "import collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\n", "completion": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ss = set()\n        ans = i = 0\n        for j, c in enumerate(s):\n            while c in ss:\n                ss.remove(s[i])\n                i += 1\n            ss.add(c)\n            ans = max(ans, j - i + 1)\n        return ans\n", "entry_point": "Solution().lengthOfLongestSubstring", "test": "def check(candidate):\n    assert candidate(s = \"abcabcbb\") == 3\n    assert candidate(s = \"bbbbb\") == 1\n    assert candidate(s = \"pwwkew\") == 3\n    assert candidate(s = \"abcdabcabcabcd\") == 4\n    assert candidate(s = \"abcdefgabcdefgabcdefgabcdefg\") == 7\n    assert candidate(s = \"aabbccddeeff\") == 2\n    assert candidate(s = \"sldfjldskfjdslkfjsdkljflkjsdfljfsdlkflskdjflsdjflskdjflsdkjflsdfjlsd\") == 6\n    assert candidate(s = \"racecar\") == 4\n    assert candidate(s = \"abcdefghijklmnopqrstuvwxyz\") == 26\n    assert candidate(s = \"aabacbebebe\") == 4\n    assert candidate(s = \"ekdvdfis\") == 5\n    assert candidate(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz1234567890abcdefghijklmnopqrstuvwxyz\") == 36\n    assert candidate(s = \"abbaabbaabba\") == 2\n    assert candidate(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\") == 2\n    assert candidate(s = \"abcdefghihgfedcba\") == 9\n    assert candidate(s = \"abcdeffedcba\") == 6\n    assert candidate(s = \"aaaaaaaabbbbbbbccccccdddddeeeeeeffffffffggggggg\") == 2\n    assert candidate(s = \"tmmzuxt\") == 5\n    assert candidate(s = \"nfpdmpi\") == 5\n    assert candidate(s = \"anviaj\") == 5\n    assert candidate(s = \"abcdeabcde\") == 5\n    assert candidate(s = \"abcdabcabcd\") == 4\n    assert candidate(s = \"dvdf\") == 3\n    assert candidate(s = \"zyxwvutsrqponmlkjihgfedcba\") == 26\n    assert candidate(s = \"abcdabcdeabcdabcdeabcd\") == 5\n    assert candidate(s = \"rjqzupkoz\") == 8\n    assert candidate(s = \"ababababababababab\") == 2\n    assert candidate(s = \"!@#$%^&*()_+!@#$%^&*()_+\") == 12\n    assert candidate(s = \"cdddddddddddddd\") == 2\n    assert candidate(s = \"wobgrovw\") == 6\n    assert candidate(s = \"abba\") == 2\n    assert candidate(s = \"abcbacabc\") == 3\n    assert candidate(s = \"ohvhjdml\") == 6\n    assert candidate(s = \"123456789012345678901234567890\") == 10\n    assert candidate(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz1234567890!@#$%^&*()_+\") == 23\n    assert candidate(s = \"12345678901234567890\") == 10\n    assert candidate(s = \"abcdabcabcabcd\") == 4\n    assert candidate(s = \"abcdefgabcdefgabcdefgabcdefg\") == 7\n    assert candidate(s = \"aabbccddeeff\") == 2\n    assert candidate(s = \"sldfjldskfjdslkfjsdkljflkjsdfljfsdlkflskdjflsdjflskdjflsdkjflsdfjlsd\") == 6\n    assert candidate(s = \"racecar\") == 4\n    assert candidate(s = \"abcdefghijklmnopqrstuvwxyz\") == 26\n    assert candidate(s = \"aabacbebebe\") == 4\n    assert candidate(s = \"ekdvdfis\") == 5\n    assert candidate(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz1234567890abcdefghijklmnopqrstuvwxyz\") == 36\n    assert candidate(s = \"abbaabbaabba\") == 2\n    assert candidate(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\") == 2\n    assert candidate(s = \"abcdefghihgfedcba\") == 9\n    assert candidate(s = \"abcdeffedcba\") == 6\n    assert candidate(s = \"aaaaaaaabbbbbbbccccccdddddeeeeeeffffffffggggggg\") == 2\n    assert candidate(s = \"tmmzuxt\") == 5\n    assert candidate(s = \"nfpdmpi\") == 5\n    assert candidate(s = \"anviaj\") == 5\n    assert candidate(s = \"abcdeabcde\") == 5\n    assert candidate(s = \"abcdabcabcd\") == 4\n    assert candidate(s = \"dvdf\") == 3\n    assert candidate(s = \"zyxwvutsrqponmlkjihgfedcba\") == 26\n    assert candidate(s = \"abcdabcdeabcdabcdeabcd\") == 5\n    assert candidate(s = \"rjqzupkoz\") == 8\n    assert candidate(s = \"ababababababababab\") == 2\n    assert candidate(s = \"!@#$%^&*()_+!@#$%^&*()_+\") == 12\n    assert candidate(s = \"cdddddddddddddd\") == 2\n    assert candidate(s = \"wobgrovw\") == 6\n    assert candidate(s = \"abba\") == 2\n    assert candidate(s = \"abcbacabc\") == 3\n    assert candidate(s = \"ohvhjdml\") == 6\n    assert candidate(s = \"123456789012345678901234567890\") == 10\n    assert candidate(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz1234567890!@#$%^&*()_+\") == 23\n    assert candidate(s = \"12345678901234567890\") == 10\n", "input_output": [{"input": "s = \"abcabcbb\"", "output": "3"}, {"input": "s = \"bbbbb\"", "output": "1"}, {"input": "s = \"pwwkew\"", "output": "3"}, {"input": "s = \"abcdabcabcabcd\"", "output": "4"}, {"input": "s = \"abcdefgabcdefgabcdefgabcdefg\"", "output": "7"}, {"input": "s = \"aabbccddeeff\"", "output": "2"}, {"input": "s = \"sldfjldskfjdslkfjsdkljflkjsdfljfsdlkflskdjflsdjflskdjflsdkjflsdfjlsd\"", "output": "6"}, {"input": "s = \"racecar\"", "output": "4"}, {"input": "s = \"abcdefghijklmnopqrstuvwxyz\"", "output": "26"}, {"input": "s = \"aabacbebebe\"", "output": "4"}, {"input": "s = \"ekdvdfis\"", "output": "5"}, {"input": "s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz1234567890abcdefghijklmnopqrstuvwxyz\"", "output": "36"}, {"input": "s = \"abbaabbaabba\"", "output": "2"}, {"input": "s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"", "output": "2"}, {"input": "s = \"abcdefghihgfedcba\"", "output": "9"}, {"input": "s = \"abcdeffedcba\"", "output": "6"}, {"input": "s = \"aaaaaaaabbbbbbbccccccdddddeeeeeeffffffffggggggg\"", "output": "2"}, {"input": "s = \"tmmzuxt\"", "output": "5"}, {"input": "s = \"nfpdmpi\"", "output": "5"}, {"input": "s = \"anviaj\"", "output": "5"}, {"input": "s = \"abcdeabcde\"", "output": "5"}, {"input": "s = \"abcdabcabcd\"", "output": "4"}, {"input": "s = \"dvdf\"", "output": "3"}, {"input": "s = \"zyxwvutsrqponmlkjihgfedcba\"", "output": "26"}, {"input": "s = \"abcdabcdeabcdabcdeabcd\"", "output": "5"}, {"input": "s = \"rjqzupkoz\"", "output": "8"}, {"input": "s = \"ababababababababab\"", "output": "2"}, {"input": "s = \"!@#$%^&*()_+!@#$%^&*()_+\"", "output": "12"}, {"input": "s = \"cdddddddddddddd\"", "output": "2"}, {"input": "s = \"wobgrovw\"", "output": "6"}, {"input": "s = \"abba\"", "output": "2"}, {"input": "s = \"abcbacabc\"", "output": "3"}, {"input": "s = \"ohvhjdml\"", "output": "6"}, {"input": "s = \"123456789012345678901234567890\"", "output": "10"}, {"input": "s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz1234567890!@#$%^&*()_+\"", "output": "23"}, {"input": "s = \"12345678901234567890\"", "output": "10"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a string s, find the length of the longest substring without repeating characters.\n \nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n \nConstraints:\n\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_index_map = {}\n        longest = 0\n        start = 0\n        \n        for i, char in enumerate(s):\n            if char in char_index_map and char_index_map[char] >= start:\n                start = char_index_map[char] + 1\n            char_index_map[char] = i\n            longest = max(longest, i - start + 1)\n        \n        return longest\n```\n\nThis solution uses a sliding window approach with a hash map to keep track of the last seen index of each character. It iterates through the string, updating the start of the window when a repeated character is found, and calculates the length of the current substring without repeating characters. The longest length found during the iteration is returned as the result."}
{"task_id": "median-of-two-sorted-arrays", "question_id": 4, "difficulty": "Hard", "tags": ["Array", "Binary Search", "Divide and Conquer"], "problem_description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n \nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n \nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106\n\n", "starter_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        def f(i: int, j: int, k: int) -> int:\n            if i >= m:\n                return nums2[j + k - 1]\n            if j >= n:\n                return nums1[i + k - 1]\n            if k == 1:\n                return min(nums1[i], nums2[j])\n            p = k // 2\n            x = nums1[i + p - 1] if i + p - 1 < m else inf\n            y = nums2[j + p - 1] if j + p - 1 < n else inf\n            return f(i + p, j, k - p) if x < y else f(i, j + p, k - p)\n\n        m, n = len(nums1), len(nums2)\n        a = f(0, 0, (m + n + 1) // 2)\n        b = f(0, 0, (m + n + 2) // 2)\n        return (a + b) / 2\n", "entry_point": "Solution().findMedianSortedArrays", "test": "def check(candidate):\n    assert candidate(nums1 = [100, 200, 300],nums2 = [150, 250, 350]) == 225.0\n    assert candidate(nums1 = [2],nums2 = []) == 2.0\n    assert candidate(nums1 = [1, 3],nums2 = [2]) == 2.0\n    assert candidate(nums1 = [1],nums2 = [2, 3, 4, 5, 6, 7, 8, 9, 10]) == 5.5\n    assert candidate(nums1 = [1000000],nums2 = [-1000000]) == 0.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9],nums2 = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 10.0\n    assert candidate(nums1 = [1, 3, 5, 7],nums2 = [2, 4, 6, 8]) == 4.5\n    assert candidate(nums1 = [10, 20, 30],nums2 = [5, 15, 25, 35, 45]) == 22.5\n    assert candidate(nums1 = [0, 0],nums2 = [0, 0]) == 0.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],nums2 = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 10.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5],nums2 = [6, 7, 8, 9, 10]) == 5.5\n    assert candidate(nums1 = [1, 2, 3],nums2 = [0, 4, 5, 6]) == 3.0\n    assert candidate(nums1 = [5, 6],nums2 = [1, 2, 3, 4, 7, 8]) == 4.5\n    assert candidate(nums1 = [1, 3, 5, 7],nums2 = [2, 4, 6, 8, 10]) == 5.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6],nums2 = [0]) == 3.0\n    assert candidate(nums1 = [1, 2, 3],nums2 = [4]) == 2.5\n    assert candidate(nums1 = [1, 2],nums2 = [3]) == 2.0\n    assert candidate(nums1 = [1, 3, 5],nums2 = [2, 4, 6]) == 3.5\n    assert candidate(nums1 = [1],nums2 = [2, 3, 4]) == 2.5\n    assert candidate(nums1 = [1, 2],nums2 = [3, 4]) == 2.5\n    assert candidate(nums1 = [10, 20, 30, 40, 50],nums2 = [5, 15, 25, 35, 45]) == 27.5\n    assert candidate(nums1 = [],nums2 = [1]) == 1.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29],nums2 = [2, 4, 6, 8, 10]) == 10.5\n    assert candidate(nums1 = [1000000, 1000001, 1000002, 1000003, 1000004],nums2 = [999999, 1000000, 1000005, 1000010]) == 1000002.0\n    assert candidate(nums1 = [-1000000, -999999, -999998],nums2 = [-1000001, -999997, -999995, -999993, -999991]) == -999997.5\n    assert candidate(nums1 = [5, 9, 11, 19],nums2 = [1, 3, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 17, 18]) == 10.5\n    assert candidate(nums1 = [-5, -3, -1],nums2 = [-6, -4, -2, 0]) == -3.0\n    assert candidate(nums1 = [-10, -5, 0, 5, 10],nums2 = [-7, -3, 2, 7, 12]) == 1.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]) == 15.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19],nums2 = [2, 4, 6, 8, 10]) == 8.0\n    assert candidate(nums1 = [-1000000],nums2 = [0, 1000000]) == 0.0\n    assert candidate(nums1 = [1],nums2 = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 10.5\n    assert candidate(nums1 = [-10, -9, -8, -7, -6],nums2 = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) == -2.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5],nums2 = [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 10.5\n    assert candidate(nums1 = [1],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]) == 15.0\n    assert candidate(nums1 = [1, 5, 9, 13],nums2 = [2, 6, 10, 14, 18]) == 9.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5],nums2 = [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 8.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5],nums2 = [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 8.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],nums2 = [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) == 0.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) == 10.5\n    assert candidate(nums1 = [-5, -3, -1, 1, 3, 5],nums2 = [-6, -4, -2, 0, 2, 4, 6]) == 0.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9],nums2 = [2, 4, 6, 8, 10, 12, 14, 16]) == 7.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],nums2 = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 10.5\n    assert candidate(nums1 = [1],nums2 = [1000000]) == 500000.5\n    assert candidate(nums1 = [5, 15, 25, 35, 45],nums2 = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 37.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],nums2 = [26, 27, 28, 29, 30]) == 15.5\n    assert candidate(nums1 = [-1000000, -999999, -999998],nums2 = [-1000001, -1000000, -999999, -999998]) == -999999.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],nums2 = [16, 17, 18, 19, 20]) == 10.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],nums2 = [21, 22, 23, 24, 25]) == 13.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],nums2 = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]) == 25.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15],nums2 = [2, 4, 6, 8, 10, 12, 14, 16]) == 8.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],nums2 = [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]) == 20.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9],nums2 = [0, 2, 4, 6, 8]) == 4.5\n    assert candidate(nums1 = [100, 200, 300, 400, 500],nums2 = [5, 15, 25, 35, 45, 55]) == 55.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],nums2 = [31, 32, 33, 34, 35, 36, 37, 38, 39, 40]) == 20.5\n    assert candidate(nums1 = [],nums2 = [1, 3, 5, 7, 9]) == 5.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]) == 15.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]) == 20.5\n    assert candidate(nums1 = [100, 200, 300, 400, 500],nums2 = [50, 150, 250, 350, 450, 550]) == 300.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],nums2 = [21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) == 15.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]) == 20.5\n    assert candidate(nums1 = [10, 20, 30, 40, 50],nums2 = [5, 15, 25, 35, 45, 55]) == 30.0\n    assert candidate(nums1 = [1, 2, 3],nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 4.0\n    assert candidate(nums1 = [-1, -3, -5, -7, -9],nums2 = [-2, -4, -6, -8, -10]) == -5.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11],nums2 = [2, 4, 6, 8, 10, 12]) == 6.5\n    assert candidate(nums1 = [100, 200, 300, 400, 500],nums2 = [50, 150, 250, 350, 450, 550, 650]) == 325.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],nums2 = [21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) == 15.5\n    assert candidate(nums1 = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000],nums2 = [500, 1500, 2500, 3500, 4500, 5500, 6500, 7500, 8500, 9500, 10500]) == 5500.0\n    assert candidate(nums1 = [-10, -8, -6, -4, -2],nums2 = [-9, -7, -5, -3, -1]) == -5.5\n    assert candidate(nums1 = [1000000],nums2 = [999999]) == 999999.5\n    assert candidate(nums1 = [-5, -3, -1, 1, 3],nums2 = [-10, -8, -6, -4, -2]) == -3.5\n    assert candidate(nums1 = [],nums2 = [1, 2, 3, 4, 5]) == 3.0\n    assert candidate(nums1 = [1, 5, 9, 13, 17],nums2 = [2, 6, 10, 14, 18]) == 9.5\n    assert candidate(nums1 = [1000000, 1000001, 1000002],nums2 = [999999, 1000000, 1000001, 1000002]) == 1000001.0\n    assert candidate(nums1 = [100000, 100001, 100002, 100003, 100004],nums2 = [100005, 100006, 100007, 100008, 100009]) == 100004.5\n    assert candidate(nums1 = [-5, -4, -3, -2, -1],nums2 = [0, 1, 2, 3, 4, 5]) == 0.0\n    assert candidate(nums1 = [100000],nums2 = [-100000, -99999, -99998, -99997, -99996, -99995]) == -99997.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],nums2 = []) == 5.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5],nums2 = []) == 3.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39],nums2 = [2, 4, 6, 8, 10]) == 15.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9],nums2 = [2, 4, 6, 8, 10]) == 5.5\n    assert candidate(nums1 = [],nums2 = [1, 2, 3, 4, 5]) == 3.0\n    assert candidate(nums1 = [-5, -3, 0, 8],nums2 = [-10, -4, 2, 6, 12]) == 0.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],nums2 = [16, 17, 18, 19, 20, 21, 22, 23, 24, 25]) == 13.0\n    assert candidate(nums1 = [-1, 3, 5, 7, 9],nums2 = [-2, -4, -6, -8, -10]) == -5.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50]) == 25.5\n    assert candidate(nums1 = [1, 2, 2, 3, 3],nums2 = [2, 2, 3, 3, 4, 4, 5, 5]) == 3.0\n    assert candidate(nums1 = [100, 200, 300],nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]) == 6.5\n    assert candidate(nums1 = [],nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 10.5\n    assert candidate(nums1 = [],nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 5.5\n    assert candidate(nums1 = [1, 2, 3],nums2 = [4, 5, 6, 7, 8, 9, 10]) == 5.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],nums2 = []) == 13.0\n    assert candidate(nums1 = [100, 200, 300, 400, 500],nums2 = [50, 150, 250, 350, 450, 550]) == 300.0\n    assert candidate(nums1 = [-5, 0, 3, 8, 12],nums2 = [-10, -1, 2, 4, 9, 14]) == 3.0\n    assert candidate(nums1 = [50, 60, 70, 80, 90],nums2 = [10, 20, 30, 40]) == 50.0\n    assert candidate(nums1 = [1, 3, 5],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]) == 18.0\n    assert candidate(nums1 = [1, 5, 7, 9, 11, 13],nums2 = [2, 4, 6, 8, 10, 12, 14]) == 8.0\n    assert candidate(nums1 = [-10, -5, 0, 5, 10],nums2 = [-20, -15, -1, 1, 6, 11, 15, 20]) == 1.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5],nums2 = [6, 7, 8, 9, 10, 11, 12]) == 6.5\n    assert candidate(nums1 = [-1, -2, -3, -4, -5],nums2 = [-10, -9, -8, -7, -6]) == -3.5\n    assert candidate(nums1 = [0, 0, 0, 0],nums2 = [0, 0, 0, 0]) == 0.0\n    assert candidate(nums1 = [5, 15, 25, 35, 45],nums2 = [10, 20, 30, 40, 50, 60]) == 30.0\n    assert candidate(nums1 = [100, 200, 300],nums2 = [50, 150, 250, 350]) == 200.0\n    assert candidate(nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19],nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26]) == 12.0\n    assert candidate(nums1 = [1],nums2 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 1.0\n    assert candidate(nums1 = [-100000, -99999, -99998],nums2 = [-99997, -99996, -99995, -99994, -99993, -99992]) == -99996.0\n    assert candidate(nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],nums2 = []) == 10.5\n    assert candidate(nums1 = [1, 2, 3, 4, 5],nums2 = []) == 3.0\n    assert candidate(nums1 = [1],nums2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]) == 19.0\n    assert candidate(nums1 = [1, 2, 2, 3, 4],nums2 = [2, 2, 3, 4, 5]) == 2.5\n    assert candidate(nums1 = [1, 3, 5, 7, 9],nums2 = [2, 4, 6, 8, 10, 12, 14]) == 6.5\n    assert candidate(nums1 = [100, 200, 300, 400],nums2 = [50, 150, 250, 350, 450, 550]) == 275.0\n", "input_output": [{"input": "nums1 = [100,200,300], nums2 = [150,250,350]", "output": "225.0"}, {"input": "nums1 = [2], nums2 = []", "output": "2.0"}, {"input": "nums1 = [1,3], nums2 = [2]", "output": "2.0"}, {"input": "nums1 = [1], nums2 = [2,3,4,5,6,7,8,9,10]", "output": "5.5"}, {"input": "nums1 = [1000000], nums2 = [-1000000]", "output": "0.0"}, {"input": "nums1 = [1,2,3,4,5,6,7,8,9], nums2 = [10,11,12,13,14,15,16,17,18,19]", "output": "10.0"}, {"input": "nums1 = [1,3,5,7], nums2 = [2,4,6,8]", "output": "4.5"}, {"input": "nums1 = [10,20,30], nums2 = [5,15,25,35,45]", "output": "22.5"}, {"input": "nums1 = [0,0], nums2 = [0,0]", "output": "0.0"}, {"input": "nums1 = [1,2,3,4,5,6,7,8,9,10], nums2 = [11,12,13,14,15,16,17,18,19,20]", "output": "10.5"}, {"input": "nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]", "output": "5.5"}, {"input": "nums1 = [1,2,3], nums2 = [0,4,5,6]", "output": "3.0"}, {"input": "nums1 = [5,6], nums2 = [1,2,3,4,7,8]", "output": "4.5"}, {"input": "nums1 = [1,3,5,7], nums2 = [2,4,6,8,10]", "output": "5.0"}, {"input": "nums1 = [1,2,3,4,5,6], nums2 = [0]", "output": "3.0"}, {"input": "nums1 = [1,2,3], nums2 = [4]", "output": "2.5"}, {"input": "nums1 = [1,2], nums2 = [3]", "output": "2.0"}, {"input": "nums1 = [1,3,5], nums2 = [2,4,6]", "output": "3.5"}, {"input": "nums1 = [1], nums2 = [2,3,4]", "output": "2.5"}, {"input": "nums1 = [1,2], nums2 = [3,4]", "output": "2.5"}, {"input": "nums1 = [10,20,30,40,50], nums2 = [5,15,25,35,45]", "output": "27.5"}, {"input": "nums1 = [], nums2 = [1]", "output": "1.0"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29], nums2 = [2, 4, 6, 8, 10]", "output": "10.5"}, {"input": "nums1 = [1000000, 1000001, 1000002, 1000003, 1000004], nums2 = [999999, 1000000, 1000005, 1000010]", "output": "1000002.0"}, {"input": "nums1 = [-1000000, -999999, -999998], nums2 = [-1000001, -999997, -999995, -999993, -999991]", "output": "-999997.5"}, {"input": "nums1 = [5, 9, 11, 19], nums2 = [1, 3, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 17, 18]", "output": "10.5"}, {"input": "nums1 = [-5, -3, -1], nums2 = [-6, -4, -2, 0]", "output": "-3.0"}, {"input": "nums1 = [-10, -5, 0, 5, 10], nums2 = [-7, -3, 2, 7, 12]", "output": "1.0"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29], nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]", "output": "15.5"}, {"input": "nums1 = [1,3,5,7,9,11,13,15,17,19], nums2 = [2,4,6,8,10]", "output": "8.0"}, {"input": "nums1 = [-1000000], nums2 = [0,1000000]", "output": "0.0"}, {"input": "nums1 = [1], nums2 = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]", "output": "10.5"}, {"input": "nums1 = [-10, -9, -8, -7, -6], nums2 = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]", "output": "-2.5"}, {"input": "nums1 = [1, 2, 3, 4, 5], nums2 = [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]", "output": "10.5"}, {"input": "nums1 = [1], nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]", "output": "15.0"}, {"input": "nums1 = [1, 5, 9, 13], nums2 = [2, 6, 10, 14, 18]", "output": "9.0"}, {"input": "nums1 = [1, 2, 3, 4, 5], nums2 = [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]", "output": "8.0"}, {"input": "nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10,11,12,13,14,15]", "output": "8.0"}, {"input": "nums1 = [1,2,3,4,5,6,7,8,9,10], nums2 = [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]", "output": "0.0"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]", "output": "10.5"}, {"input": "nums1 = [-5, -3, -1, 1, 3, 5], nums2 = [-6, -4, -2, 0, 2, 4, 6]", "output": "0.0"}, {"input": "nums1 = [1, 3, 5, 7, 9], nums2 = [2, 4, 6, 8, 10, 12, 14, 16]", "output": "7.0"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], nums2 = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]", "output": "10.5"}, {"input": "nums1 = [1], nums2 = [1000000]", "output": "500000.5"}, {"input": "nums1 = [5, 15, 25, 35, 45], nums2 = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]", "output": "37.5"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], nums2 = [26, 27, 28, 29, 30]", "output": "15.5"}, {"input": "nums1 = [-1000000, -999999, -999998], nums2 = [-1000001, -1000000, -999999, -999998]", "output": "-999999.0"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], nums2 = [16, 17, 18, 19, 20]", "output": "10.5"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], nums2 = [21, 22, 23, 24, 25]", "output": "13.0"}, {"input": "nums1 = [1,2,3,4,5,6,7,8,9,10], nums2 = [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]", "output": "25.5"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15], nums2 = [2, 4, 6, 8, 10, 12, 14, 16]", "output": "8.5"}, {"input": "nums1 = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], nums2 = [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]", "output": "20.5"}, {"input": "nums1 = [1, 3, 5, 7, 9], nums2 = [0, 2, 4, 6, 8]", "output": "4.5"}, {"input": "nums1 = [100, 200, 300, 400, 500], nums2 = [5, 15, 25, 35, 45, 55]", "output": "55.0"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], nums2 = [31, 32, 33, 34, 35, 36, 37, 38, 39, 40]", "output": "20.5"}, {"input": "nums1 = [], nums2 = [1,3,5,7,9]", "output": "5.0"}, {"input": "nums1 = [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29], nums2 = [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30]", "output": "15.5"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39], nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]", "output": "20.5"}, {"input": "nums1 = [100,200,300,400,500], nums2 = [50,150,250,350,450,550]", "output": "300.0"}, {"input": "nums1 = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], nums2 = [21,22,23,24,25,26,27,28,29,30]", "output": "15.5"}, {"input": "nums1 = [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39], nums2 = [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]", "output": "20.5"}, {"input": "nums1 = [10, 20, 30, 40, 50], nums2 = [5, 15, 25, 35, 45, 55]", "output": "30.0"}, {"input": "nums1 = [1,2,3], nums2 = [1,2,3,4,5,6,7,8,9,10]", "output": "4.0"}, {"input": "nums1 = [-1, -3, -5, -7, -9], nums2 = [-2, -4, -6, -8, -10]", "output": "-5.5"}, {"input": "nums1 = [1,3,5,7,9,11], nums2 = [2,4,6,8,10,12]", "output": "6.5"}, {"input": "nums1 = [100, 200, 300, 400, 500], nums2 = [50, 150, 250, 350, 450, 550, 650]", "output": "325.0"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], nums2 = [21, 22, 23, 24, 25, 26, 27, 28, 29, 30]", "output": "15.5"}, {"input": "nums1 = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000], nums2 = [500, 1500, 2500, 3500, 4500, 5500, 6500, 7500, 8500, 9500, 10500]", "output": "5500.0"}, {"input": "nums1 = [-10, -8, -6, -4, -2], nums2 = [-9, -7, -5, -3, -1]", "output": "-5.5"}, {"input": "nums1 = [1000000], nums2 = [999999]", "output": "999999.5"}, {"input": "nums1 = [-5, -3, -1, 1, 3], nums2 = [-10, -8, -6, -4, -2]", "output": "-3.5"}, {"input": "nums1 = [], nums2 = [1, 2, 3, 4, 5]", "output": "3.0"}, {"input": "nums1 = [1,5,9,13,17], nums2 = [2,6,10,14,18]", "output": "9.5"}, {"input": "nums1 = [1000000, 1000001, 1000002], nums2 = [999999, 1000000, 1000001, 1000002]", "output": "1000001.0"}, {"input": "nums1 = [100000, 100001, 100002, 100003, 100004], nums2 = [100005, 100006, 100007, 100008, 100009]", "output": "100004.5"}, {"input": "nums1 = [-5,-4,-3,-2,-1], nums2 = [0,1,2,3,4,5]", "output": "0.0"}, {"input": "nums1 = [100000], nums2 = [-100000, -99999, -99998, -99997, -99996, -99995]", "output": "-99997.0"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], nums2 = []", "output": "5.5"}, {"input": "nums1 = [1,2,3,4,5], nums2 = []", "output": "3.0"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39], nums2 = [2, 4, 6, 8, 10]", "output": "15.0"}, {"input": "nums1 = [1, 3, 5, 7, 9], nums2 = [2, 4, 6, 8, 10]", "output": "5.5"}, {"input": "nums1 = [], nums2 = [1,2,3,4,5]", "output": "3.0"}, {"input": "nums1 = [-5, -3, 0, 8], nums2 = [-10, -4, 2, 6, 12]", "output": "0.0"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], nums2 = [16, 17, 18, 19, 20, 21, 22, 23, 24, 25]", "output": "13.0"}, {"input": "nums1 = [-1,3,5,7,9], nums2 = [-2,-4,-6,-8,-10]", "output": "-5.5"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49], nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50]", "output": "25.5"}, {"input": "nums1 = [1, 2, 2, 3, 3], nums2 = [2, 2, 3, 3, 4, 4, 5, 5]", "output": "3.0"}, {"input": "nums1 = [100, 200, 300], nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]", "output": "6.5"}, {"input": "nums1 = [], nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]", "output": "10.5"}, {"input": "nums1 = [], nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "output": "5.5"}, {"input": "nums1 = [1, 2, 3], nums2 = [4, 5, 6, 7, 8, 9, 10]", "output": "5.5"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], nums2 = []", "output": "13.0"}, {"input": "nums1 = [100, 200, 300, 400, 500], nums2 = [50, 150, 250, 350, 450, 550]", "output": "300.0"}, {"input": "nums1 = [-5,0,3,8,12], nums2 = [-10,-1,2,4,9,14]", "output": "3.0"}, {"input": "nums1 = [50,60,70,80,90], nums2 = [10,20,30,40]", "output": "50.0"}, {"input": "nums1 = [1, 3, 5], nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]", "output": "18.0"}, {"input": "nums1 = [1,5,7,9,11,13], nums2 = [2,4,6,8,10,12,14]", "output": "8.0"}, {"input": "nums1 = [-10, -5, 0, 5, 10], nums2 = [-20, -15, -1, 1, 6, 11, 15, 20]", "output": "1.0"}, {"input": "nums1 = [1, 2, 3, 4, 5], nums2 = [6, 7, 8, 9, 10, 11, 12]", "output": "6.5"}, {"input": "nums1 = [-1, -2, -3, -4, -5], nums2 = [-10, -9, -8, -7, -6]", "output": "-3.5"}, {"input": "nums1 = [0, 0, 0, 0], nums2 = [0, 0, 0, 0]", "output": "0.0"}, {"input": "nums1 = [5, 15, 25, 35, 45], nums2 = [10, 20, 30, 40, 50, 60]", "output": "30.0"}, {"input": "nums1 = [100, 200, 300], nums2 = [50, 150, 250, 350]", "output": "200.0"}, {"input": "nums1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], nums2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26]", "output": "12.0"}, {"input": "nums1 = [1], nums2 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", "output": "1.0"}, {"input": "nums1 = [-100000, -99999, -99998], nums2 = [-99997, -99996, -99995, -99994, -99993, -99992]", "output": "-99996.0"}, {"input": "nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], nums2 = []", "output": "10.5"}, {"input": "nums1 = [1, 2, 3, 4, 5], nums2 = []", "output": "3.0"}, {"input": "nums1 = [1], nums2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]", "output": "19.0"}, {"input": "nums1 = [1, 2, 2, 3, 4], nums2 = [2, 2, 3, 4, 5]", "output": "2.5"}, {"input": "nums1 = [1, 3, 5, 7, 9], nums2 = [2, 4, 6, 8, 10, 12, 14]", "output": "6.5"}, {"input": "nums1 = [100, 200, 300, 400], nums2 = [50, 150, 250, 350, 450, 550]", "output": "275.0"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n \nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n \nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nfrom typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            # If partitionX is 0 it means nothing is there on left side. Use -inf for maxLeftX\n            # If partitionX is length of input then there is nothing on right side. Use +inf for minRightX\n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                # We have partitioned array at correct place\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                # We are too far on right side for partitionX. Go on left side.\n                high = partitionX - 1\n            else:\n                # We are too far on left side for partitionX. Go on right side.\n                low = partitionX + 1\n```\n\nThis solution uses a binary search approach to find the median in O(log(min(m, n))) time, which meets the problem's complexity requirement. The idea is to partition both arrays such that all elements on the left side are less than or equal to all elements on the right side."}
{"task_id": "longest-palindromic-substring", "question_id": 5, "difficulty": "Medium", "tags": ["Two Pointers", "String", "Dynamic Programming"], "problem_description": "Given a string s, return the longest palindromic substring in s.\n \nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n \nConstraints:\n\n1 <= s.length <= 1000\ns consist of only digits and English letters.\n\n", "starter_code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        f = [[True] * n for _ in range(n)]\n        k, mx = 0, 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                f[i][j] = False\n                if s[i] == s[j]:\n                    f[i][j] = f[i + 1][j - 1]\n                    if f[i][j] and mx < j - i + 1:\n                        k, mx = i, j - i + 1\n        return s[k : k + mx]\n", "entry_point": "Solution().longestPalindrome", "test": "def check(candidate):\n    assert candidate(s = \"abba\") == \"abba\"\n    assert candidate(s = \"aaaa\") == \"aaaa\"\n    assert candidate(s = \"abacdfgdcaba\") == \"aba\"\n    assert candidate(s = \"ac\") == \"a\"\n    assert candidate(s = \"babad\") == \"aba\"\n    assert candidate(s = \"noon\") == \"noon\"\n    assert candidate(s = \"cbbd\") == \"bb\"\n    assert candidate(s = \"abcba\") == \"abcba\"\n    assert candidate(s = \"bcbabcbabcba\") == \"bcbabcbabcb\"\n    assert candidate(s = \"noonhighnoon\") == \"noon\"\n    assert candidate(s = \"forgeeksskeegfor\") == \"geeksskeeg\"\n    assert candidate(s = \"aaabaaaa\") == \"aaabaaa\"\n    assert candidate(s = \"abcdedcba\") == \"abcdedcba\"\n    assert candidate(s = \"aaa\") == \"aaa\"\n    assert candidate(s = \"aaaaa\") == \"aaaaa\"\n    assert candidate(s = \"racecar\") == \"racecar\"\n    assert candidate(s = \"a\") == \"a\"\n    assert candidate(s = \"abcdefg\") == \"a\"\n    assert candidate(s = \"aabbccddeeeffgg\") == \"eee\"\n    assert candidate(s = \"abcdedcba12321\") == \"abcdedcba\"\n    assert candidate(s = \"xxyyyxyxyxyxyxyxxyyxyxyxyxyxyx\") == \"xyxyxyxyxyx\"\n    assert candidate(s = \"thisisanexamplewithlongestpalindromeonyxdxyxdx\") == \"xdxyxdx\"\n    assert candidate(s = \"12345678987654321\") == \"12345678987654321\"\n    assert candidate(s = \"xyzaaazyxzyzyxyz\") == \"xyzaaazyx\"\n    assert candidate(s = \"12321abcdcba45654\") == \"abcdcba\"\n    assert candidate(s = \"012210\") == \"012210\"\n    assert candidate(s = \"tattarrattat\") == \"tattarrattat\"\n    assert candidate(s = \"aabbabbaa\") == \"aabbabbaa\"\n    assert candidate(s = \"abacdfgdcaba12321\") == \"12321\"\n    assert candidate(s = \"xyxxyxyxyxyxyxyx\") == \"xyxyxyxyxyxyx\"\n    assert candidate(s = \"1234321abcdefghgfedcba\") == \"abcdefghgfedcba\"\n    assert candidate(s = \"abababababababababababababababababababababababababababababababab\") == \"bababababababababababababababababababababababababababababababab\"\n    assert candidate(s = \"abacdfgdcabaxxxabcdcba\") == \"abcdcba\"\n    assert candidate(s = \"12321abccba45654\") == \"abccba\"\n    assert candidate(s = \"12321abcdedcbavcvcv\") == \"abcdedcba\"\n    assert candidate(s = \"abcbaekayakecivic\") == \"ekayake\"\n    assert candidate(s = \"noonmoonnoon\") == \"oonnoo\"\n    assert candidate(s = \"abcbaxxxxxabcdcba\") == \"cbaxxxxxabc\"\n    assert candidate(s = \"noonhighnoonnoon\") == \"noonnoon\"\n    assert candidate(s = \"noonmidnightnoon\") == \"noon\"\n    assert candidate(s = \"abcba12321defedcba\") == \"defed\"\n    assert candidate(s = \"aabbabaaaabbaaabaaabbbbbaaaaaabbbaaaabbbbaaabbaabbbaaaabbbaaabbbbaaabbaabbaabbab\") == \"bbaaabbbbaaabb\"\n    assert candidate(s = \"ababababababababa\") == \"ababababababababa\"\n    assert candidate(s = \"noonnoonnoonnoonnoonnoon\") == \"noonnoonnoonnoonnoonnoon\"\n    assert candidate(s = \"abccbaabacdfgdcaba\") == \"abccba\"\n    assert candidate(s = \"racecarxracecar\") == \"racecarxracecar\"\n    assert candidate(s = \"madamracecarlevel\") == \"racecar\"\n    assert candidate(s = \"babcbabcbabcba\") == \"abcbabcbabcba\"\n    assert candidate(s = \"abacdfgdcabaabacdfgdcaba\") == \"dcabaabacd\"\n    assert candidate(s = \"madamintanimadaminabba\") == \"animadamina\"\n    assert candidate(s = \"noonracecarracecar\") == \"racecarracecar\"\n    assert candidate(s = \"zzzzzzzzzzzz\") == \"zzzzzzzzzzzz\"\n    assert candidate(s = \"racecar2racecar\") == \"racecar2racecar\"\n    assert candidate(s = \"zxyabcddcbaabczyx\") == \"abcddcba\"\n    assert candidate(s = \"deeee\") == \"eeee\"\n    assert candidate(s = \"abacdfgdcabacdfgdcaba\") == \"dcabacd\"\n    assert candidate(s = \"1234543216789876\") == \"123454321\"\n    assert candidate(s = \"abcbaaabcba\") == \"abcbaaabcba\"\n    assert candidate(s = \"abcdedcbaefghihgfexyzzyx\") == \"efghihgfe\"\n    assert candidate(s = \"abcdefgfebac\") == \"efgfe\"\n    assert candidate(s = \"levelhannahlevel\") == \"levelhannahlevel\"\n    assert candidate(s = \"xxyyzzzyyxx\") == \"xxyyzzzyyxx\"\n    assert candidate(s = \"abcddcbaabcddcbaxyzzyx\") == \"abcddcbaabcddcba\"\n    assert candidate(s = \"racecar12321racecar\") == \"racecar12321racecar\"\n    assert candidate(s = \"abcdeffedcba\") == \"abcdeffedcba\"\n    assert candidate(s = \"civicracecar\") == \"racecar\"\n    assert candidate(s = \"levelmadammadam\") == \"madammadam\"\n    assert candidate(s = \"zxyaxzyaz\") == \"z\"\n    assert candidate(s = \"abcdefedcba\") == \"abcdefedcba\"\n    assert candidate(s = \"12321321321321321\") == \"12321\"\n    assert candidate(s = \"xyzzyxcbaapqrqpabczyzyx\") == \"apqrqpa\"\n    assert candidate(s = \"abacdfgdcaba123321\") == \"123321\"\n    assert candidate(s = \"abacdfgdcabaxxxxxabcdcba\") == \"baxxxxxab\"\n    assert candidate(s = \"aabcdcbadefedcbaa\") == \"abcdcba\"\n    assert candidate(s = \"abcdefghijiklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba\") == \"klmnopqrstuvwxyzzyxwvutsrqponmlk\"\n    assert candidate(s = \"bananaananab\") == \"bananaananab\"\n    assert candidate(s = \"aabbccddeedcba\") == \"deed\"\n    assert candidate(s = \"noonhighnoonnoonhighnoon\") == \"hnoonnoonh\"\n    assert candidate(s = \"babaddabba\") == \"baddab\"\n    assert candidate(s = \"abababababababababababababababababababababababababababababababbababa\") == \"babababababababababababababababababababababababababababababab\"\n    assert candidate(s = \"abcdeedcba1234321xyzzyx\") == \"abcdeedcba\"\n    assert candidate(s = \"aabb\") == \"bb\"\n    assert candidate(s = \"mamamamamamamamama\") == \"amamamamamamamama\"\n    assert candidate(s = \"abcdefgfedcba\") == \"abcdefgfedcba\"\n    assert candidate(s = \"abcbabcba\") == \"abcbabcba\"\n    assert candidate(s = \"xyzzzzyxabcdefedcba\") == \"abcdefedcba\"\n    assert candidate(s = \"banana\") == \"anana\"\n    assert candidate(s = \"abcbcbcbcbcbcbcbcbcbcbcbcb\") == \"bcbcbcbcbcbcbcbcbcbcbcbcb\"\n    assert candidate(s = \"anana\") == \"anana\"\n    assert candidate(s = \"aabbccddeeeeddccbbbaa\") == \"bbccddeeeeddccbb\"\n    assert candidate(s = \"12321abcdedcba45654\") == \"abcdedcba\"\n    assert candidate(s = \"aabbccddeeffgg\") == \"gg\"\n    assert candidate(s = \"levelracecardeifiedracecar\") == \"racecardeifiedracecar\"\n    assert candidate(s = \"aaaaabbbbbaaaa\") == \"aaaabbbbbaaaa\"\n    assert candidate(s = \"abccba\") == \"abccba\"\n    assert candidate(s = \"abcdcba12321xyzzyx\") == \"abcdcba\"\n    assert candidate(s = \"12321abcba21321\") == \"abcba\"\n    assert candidate(s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\") == \"zz\"\n    assert candidate(s = \"abcdcbaxxxabcdcbaabcdcbaxxxabcdcba\") == \"abcdcbaxxxabcdcbaabcdcbaxxxabcdcba\"\n    assert candidate(s = \"xyzabcbaxyz\") == \"abcba\"\n    assert candidate(s = \"racecarannakayak\") == \"racecar\"\n    assert candidate(s = \"abacdfgdcab\") == \"aba\"\n    assert candidate(s = \"abcdeedcbafedcbe\") == \"abcdeedcba\"\n    assert candidate(s = \"a1b2c3d4c3b2a\") == \"a\"\n    assert candidate(s = \"abccccba\") == \"abccccba\"\n    assert candidate(s = \"noonnoonnoon\") == \"noonnoonnoon\"\n    assert candidate(s = \"aabbccddeeeedddccbaa\") == \"ddeeeedd\"\n    assert candidate(s = \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\") == \"A\"\n    assert candidate(s = \"acbbac\") == \"bb\"\n    assert candidate(s = \"noonlevelnoon\") == \"noonlevelnoon\"\n    assert candidate(s = \"abbaabba\") == \"abbaabba\"\n    assert candidate(s = \"rotor1234321rotor\") == \"rotor1234321rotor\"\n    assert candidate(s = \"aaaaabaaa\") == \"aaabaaa\"\n    assert candidate(s = \"abcdefghihgfedcba\") == \"abcdefghihgfedcba\"\n    assert candidate(s = \"civicdeifiedrotorlevel\") == \"deified\"\n    assert candidate(s = \"aquickbrownfoxjumpsoverthelazydog\") == \"a\"\n    assert candidate(s = \"zyxwvutsrqponmlkjihgfedcbaedcba\") == \"z\"\n    assert candidate(s = \"aabcddeffedcba\") == \"deffed\"\n    assert candidate(s = \"pppppppppppppppppppppppppppppppp\") == \"pppppppppppppppppppppppppppppppp\"\n    assert candidate(s = \"aabbccddeeeedddccbbaa\") == \"ddeeeedd\"\n    assert candidate(s = \"a1b2c3d4e5f6g7h8i9j0j9i8h7g6f5e4d3c2b1a\") == \"a1b2c3d4e5f6g7h8i9j0j9i8h7g6f5e4d3c2b1a\"\n    assert candidate(s = \"mississippi\") == \"ississi\"\n    assert candidate(s = \"zxcvbnmlkjhgfdsapoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewq\") == \"z\"\n    assert candidate(s = \"deifiedrotorlevel\") == \"deified\"\n", "input_output": [{"input": "s = \"abba\"", "output": "abba"}, {"input": "s = \"aaaa\"", "output": "aaaa"}, {"input": "s = \"abacdfgdcaba\"", "output": "aba"}, {"input": "s = \"ac\"", "output": "a"}, {"input": "s = \"babad\"", "output": "aba"}, {"input": "s = \"noon\"", "output": "noon"}, {"input": "s = \"cbbd\"", "output": "bb"}, {"input": "s = \"abcba\"", "output": "abcba"}, {"input": "s = \"bcbabcbabcba\"", "output": "bcbabcbabcb"}, {"input": "s = \"noonhighnoon\"", "output": "noon"}, {"input": "s = \"forgeeksskeegfor\"", "output": "geeksskeeg"}, {"input": "s = \"aaabaaaa\"", "output": "aaabaaa"}, {"input": "s = \"abcdedcba\"", "output": "abcdedcba"}, {"input": "s = \"aaa\"", "output": "aaa"}, {"input": "s = \"aaaaa\"", "output": "aaaaa"}, {"input": "s = \"racecar\"", "output": "racecar"}, {"input": "s = \"a\"", "output": "a"}, {"input": "s = \"abcdefg\"", "output": "a"}, {"input": "s = \"aabbccddeeeffgg\"", "output": "eee"}, {"input": "s = \"abcdedcba12321\"", "output": "abcdedcba"}, {"input": "s = \"xxyyyxyxyxyxyxyxxyyxyxyxyxyxyx\"", "output": "xyxyxyxyxyx"}, {"input": "s = \"thisisanexamplewithlongestpalindromeonyxdxyxdx\"", "output": "xdxyxdx"}, {"input": "s = \"12345678987654321\"", "output": "12345678987654321"}, {"input": "s = \"xyzaaazyxzyzyxyz\"", "output": "xyzaaazyx"}, {"input": "s = \"12321abcdcba45654\"", "output": "abcdcba"}, {"input": "s = \"012210\"", "output": "012210"}, {"input": "s = \"tattarrattat\"", "output": "tattarrattat"}, {"input": "s = \"aabbabbaa\"", "output": "aabbabbaa"}, {"input": "s = \"abacdfgdcaba12321\"", "output": "12321"}, {"input": "s = \"xyxxyxyxyxyxyxyx\"", "output": "xyxyxyxyxyxyx"}, {"input": "s = \"1234321abcdefghgfedcba\"", "output": "abcdefghgfedcba"}, {"input": "s = \"abababababababababababababababababababababababababababababababab\"", "output": "bababababababababababababababababababababababababababababababab"}, {"input": "s = \"abacdfgdcabaxxxabcdcba\"", "output": "abcdcba"}, {"input": "s = \"12321abccba45654\"", "output": "abccba"}, {"input": "s = \"12321abcdedcbavcvcv\"", "output": "abcdedcba"}, {"input": "s = \"abcbaekayakecivic\"", "output": "ekayake"}, {"input": "s = \"noonmoonnoon\"", "output": "oonnoo"}, {"input": "s = \"abcbaxxxxxabcdcba\"", "output": "cbaxxxxxabc"}, {"input": "s = \"noonhighnoonnoon\"", "output": "noonnoon"}, {"input": "s = \"noonmidnightnoon\"", "output": "noon"}, {"input": "s = \"abcba12321defedcba\"", "output": "defed"}, {"input": "s = \"aabbabaaaabbaaabaaabbbbbaaaaaabbbaaaabbbbaaabbaabbbaaaabbbaaabbbbaaabbaabbaabbab\"", "output": "bbaaabbbbaaabb"}, {"input": "s = \"ababababababababa\"", "output": "ababababababababa"}, {"input": "s = \"noonnoonnoonnoonnoonnoon\"", "output": "noonnoonnoonnoonnoonnoon"}, {"input": "s = \"abccbaabacdfgdcaba\"", "output": "abccba"}, {"input": "s = \"racecarxracecar\"", "output": "racecarxracecar"}, {"input": "s = \"madamracecarlevel\"", "output": "racecar"}, {"input": "s = \"babcbabcbabcba\"", "output": "abcbabcbabcba"}, {"input": "s = \"abacdfgdcabaabacdfgdcaba\"", "output": "dcabaabacd"}, {"input": "s = \"madamintanimadaminabba\"", "output": "animadamina"}, {"input": "s = \"noonracecarracecar\"", "output": "racecarracecar"}, {"input": "s = \"zzzzzzzzzzzz\"", "output": "zzzzzzzzzzzz"}, {"input": "s = \"racecar2racecar\"", "output": "racecar2racecar"}, {"input": "s = \"zxyabcddcbaabczyx\"", "output": "abcddcba"}, {"input": "s = \"deeee\"", "output": "eeee"}, {"input": "s = \"abacdfgdcabacdfgdcaba\"", "output": "dcabacd"}, {"input": "s = \"1234543216789876\"", "output": "123454321"}, {"input": "s = \"abcbaaabcba\"", "output": "abcbaaabcba"}, {"input": "s = \"abcdedcbaefghihgfexyzzyx\"", "output": "efghihgfe"}, {"input": "s = \"abcdefgfebac\"", "output": "efgfe"}, {"input": "s = \"levelhannahlevel\"", "output": "levelhannahlevel"}, {"input": "s = \"xxyyzzzyyxx\"", "output": "xxyyzzzyyxx"}, {"input": "s = \"abcddcbaabcddcbaxyzzyx\"", "output": "abcddcbaabcddcba"}, {"input": "s = \"racecar12321racecar\"", "output": "racecar12321racecar"}, {"input": "s = \"abcdeffedcba\"", "output": "abcdeffedcba"}, {"input": "s = \"civicracecar\"", "output": "racecar"}, {"input": "s = \"levelmadammadam\"", "output": "madammadam"}, {"input": "s = \"zxyaxzyaz\"", "output": "z"}, {"input": "s = \"abcdefedcba\"", "output": "abcdefedcba"}, {"input": "s = \"12321321321321321\"", "output": "12321"}, {"input": "s = \"xyzzyxcbaapqrqpabczyzyx\"", "output": "apqrqpa"}, {"input": "s = \"abacdfgdcaba123321\"", "output": "123321"}, {"input": "s = \"abacdfgdcabaxxxxxabcdcba\"", "output": "baxxxxxab"}, {"input": "s = \"aabcdcbadefedcbaa\"", "output": "abcdcba"}, {"input": "s = \"abcdefghijiklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba\"", "output": "klmnopqrstuvwxyzzyxwvutsrqponmlk"}, {"input": "s = \"bananaananab\"", "output": "bananaananab"}, {"input": "s = \"aabbccddeedcba\"", "output": "deed"}, {"input": "s = \"noonhighnoonnoonhighnoon\"", "output": "hnoonnoonh"}, {"input": "s = \"babaddabba\"", "output": "baddab"}, {"input": "s = \"abababababababababababababababababababababababababababababababbababa\"", "output": "babababababababababababababababababababababababababababababab"}, {"input": "s = \"abcdeedcba1234321xyzzyx\"", "output": "abcdeedcba"}, {"input": "s = \"aabb\"", "output": "bb"}, {"input": "s = \"mamamamamamamamama\"", "output": "amamamamamamamama"}, {"input": "s = \"abcdefgfedcba\"", "output": "abcdefgfedcba"}, {"input": "s = \"abcbabcba\"", "output": "abcbabcba"}, {"input": "s = \"xyzzzzyxabcdefedcba\"", "output": "abcdefedcba"}, {"input": "s = \"banana\"", "output": "anana"}, {"input": "s = \"abcbcbcbcbcbcbcbcbcbcbcbcb\"", "output": "bcbcbcbcbcbcbcbcbcbcbcbcb"}, {"input": "s = \"anana\"", "output": "anana"}, {"input": "s = \"aabbccddeeeeddccbbbaa\"", "output": "bbccddeeeeddccbb"}, {"input": "s = \"12321abcdedcba45654\"", "output": "abcdedcba"}, {"input": "s = \"aabbccddeeffgg\"", "output": "gg"}, {"input": "s = \"levelracecardeifiedracecar\"", "output": "racecardeifiedracecar"}, {"input": "s = \"aaaaabbbbbaaaa\"", "output": "aaaabbbbbaaaa"}, {"input": "s = \"abccba\"", "output": "abccba"}, {"input": "s = \"abcdcba12321xyzzyx\"", "output": "abcdcba"}, {"input": "s = \"12321abcba21321\"", "output": "abcba"}, {"input": "s = \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"", "output": "zz"}, {"input": "s = \"abcdcbaxxxabcdcbaabcdcbaxxxabcdcba\"", "output": "abcdcbaxxxabcdcbaabcdcbaxxxabcdcba"}, {"input": "s = \"xyzabcbaxyz\"", "output": "abcba"}, {"input": "s = \"racecarannakayak\"", "output": "racecar"}, {"input": "s = \"abacdfgdcab\"", "output": "aba"}, {"input": "s = \"abcdeedcbafedcbe\"", "output": "abcdeedcba"}, {"input": "s = \"a1b2c3d4c3b2a\"", "output": "a"}, {"input": "s = \"abccccba\"", "output": "abccccba"}, {"input": "s = \"noonnoonnoon\"", "output": "noonnoonnoon"}, {"input": "s = \"aabbccddeeeedddccbaa\"", "output": "ddeeeedd"}, {"input": "s = \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"", "output": "A"}, {"input": "s = \"acbbac\"", "output": "bb"}, {"input": "s = \"noonlevelnoon\"", "output": "noonlevelnoon"}, {"input": "s = \"abbaabba\"", "output": "abbaabba"}, {"input": "s = \"rotor1234321rotor\"", "output": "rotor1234321rotor"}, {"input": "s = \"aaaaabaaa\"", "output": "aaabaaa"}, {"input": "s = \"abcdefghihgfedcba\"", "output": "abcdefghihgfedcba"}, {"input": "s = \"civicdeifiedrotorlevel\"", "output": "deified"}, {"input": "s = \"aquickbrownfoxjumpsoverthelazydog\"", "output": "a"}, {"input": "s = \"zyxwvutsrqponmlkjihgfedcbaedcba\"", "output": "z"}, {"input": "s = \"aabcddeffedcba\"", "output": "deffed"}, {"input": "s = \"pppppppppppppppppppppppppppppppp\"", "output": "pppppppppppppppppppppppppppppppp"}, {"input": "s = \"aabbccddeeeedddccbbaa\"", "output": "ddeeeedd"}, {"input": "s = \"a1b2c3d4e5f6g7h8i9j0j9i8h7g6f5e4d3c2b1a\"", "output": "a1b2c3d4e5f6g7h8i9j0j9i8h7g6f5e4d3c2b1a"}, {"input": "s = \"mississippi\"", "output": "ississi"}, {"input": "s = \"zxcvbnmlkjhgfdsapoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewq\"", "output": "z"}, {"input": "s = \"deifiedrotorlevel\"", "output": "deified"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a string s, return the longest palindromic substring in s.\n \nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n \nConstraints:\n\n1 <= s.length <= 1000\ns consist of only digits and English letters.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        f = [[True] * n for _ in range(n)]\n        k, mx = 0, 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                f[i][j] = False\n                if s[i] == s[j]:\n                    f[i][j] = f[i + 1][j - 1]\n                    if f[i][j] and mx < j - i + 1:\n                        k, mx = i, j - i + 1\n        return s[k : k + mx]\n```\n\nThis solution uses dynamic programming to find the longest palindromic substring. The 2D list `f` is used to store whether the substring `s[i:j+1]` is a palindrome. The algorithm iterates over all possible substrings, updating the `f` table and keeping track of the longest palindrome found."}
{"task_id": "zigzag-conversion", "question_id": 6, "difficulty": "Medium", "tags": ["String"], "problem_description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n \nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n\n \nConstraints:\n\n1 <= s.length <= 1000\ns consists of English letters (lower-case and upper-case), ',' and '.'.\n1 <= numRows <= 1000\n\n", "starter_code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        g = [[] for _ in range(numRows)]\n        i, k = 0, -1\n        for c in s:\n            g[i].append(c)\n            if i == 0 or i == numRows - 1:\n                k = -k\n            i += k\n        return ''.join(chain(*g))\n", "entry_point": "Solution().convert", "test": "def check(candidate):\n    assert candidate(s = \"PAYPALISHIRING\",numRows = 4) == \"PINALSIGYAHRPI\"\n    assert candidate(s = \"ABCDEFGHI\",numRows = 3) == \"AEIBDFHCG\"\n    assert candidate(s = \"A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z\",numRows = 5) == \"AEIMQUY,,,,,,,,,,,,,BDFHJLNPRTVXZ,,,,,,,,,,,,CGKOSW\"\n    assert candidate(s = \"PAYPALISHIRING\",numRows = 3) == \"PAHNAPLSIIGYIR\"\n    assert candidate(s = \"A\",numRows = 1) == \"A\"\n    assert candidate(s = \"HELLO\",numRows = 5) == \"HELLO\"\n    assert candidate(s = \"ABCDEF\",numRows = 2) == \"ACEBDF\"\n    assert candidate(s = \"HELLO WORLD\",numRows = 5) == \"HREOLLWDL O\"\n    assert candidate(s = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z\",numRows = 20) == \"atM,,,,,bsuLN,,,,,crvKO,,,,,dqwJP,,,,,epxIQ,,,,,foyHR,,,,,gnzGSZ,,,,,,hmAFTY,,,,,,ilBEUX,,,,,,jkCDVW,,,\"\n    assert candidate(s = \"AB\",numRows = 1) == \"AB\"\n    assert candidate(s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",numRows = 5) == \"AIQYBHJPRXZCGKOSWDFLNTVEMU\"\n    assert candidate(s = \"ABCD\",numRows = 2) == \"ACBD\"\n    assert candidate(s = \"ABCDEFGHIJKL\",numRows = 4) == \"AGBFHLCEIKDJ\"\n    assert candidate(s = \"HELLO.WORLD.\",numRows = 3) == \"HOREL.OL.LWD\"\n    assert candidate(s = \"ABC\",numRows = 2) == \"ACB\"\n    assert candidate(s = \"ABCDEFG\",numRows = 1) == \"ABCDEFG\"\n    assert candidate(s = \"A,B.C\",numRows = 3) == \"AC,.B\"\n    assert candidate(s = \"A,B,C,D,E,F,G\",numRows = 3) == \"ACEG,,,,,,BDF\"\n    assert candidate(s = \"ABCDEFGHIJKL\",numRows = 3) == \"AEIBDFHJLCGK\"\n    assert candidate(s = \"\",numRows = 1) == \"\"\n    assert candidate(s = \"COMPLEX.EXAMPLE\",numRows = 6) == \"CAOXMMEPP.LLXEE\"\n    assert candidate(s = \"A,B,C.,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z.\",numRows = 7) == \"A,,,,,FGLMRSXYB,,,,,,,,,EHKNQTWZC,,,,,,,..DIJOPUV,,,,\"\n    assert candidate(s = \"..............................\",numRows = 10) == \"..............................\"\n    assert candidate(s = \"ZIGZAG\",numRows = 6) == \"ZIGZAG\"\n    assert candidate(s = \"ThisIsATestOfTheEmergencyBroadcastSystem\",numRows = 10) == \"TeshmrytiEgSeseetmIhnssTcaAfycTOBdetraso\"\n    assert candidate(s = \"The quick brown fox jumps over the lazy dog.\",numRows = 3) == \"Tqkofjsehadh uc rw o up vrtelz o.eibnxmo  yg\"\n    assert candidate(s = \"WithSpecialCharacters!@#$%^&*()\",numRows = 5) == \"Wic$icaat#%telre@^)hpCar!&(Shs*\"\n    assert candidate(s = \"The quick brown fox jumps over the lazy dog.\",numRows = 8) == \"Tneghw vro.eofo d ro t qbxshyu  pezikjm acul\"\n    assert candidate(s = \"This,is,a,longer,string,with,punctuation!\",numRows = 7) == \"Tnwthog,iaiilegtuos,rnhtn,a,i,c!i,srpnstu\"\n    assert candidate(s = \"\",numRows = 5) == \"\"\n    assert candidate(s = \"Short\",numRows = 1) == \"Short\"\n    assert candidate(s = \"Lorem.ipsum.dolor.sit.amet.consectetur.adipiscing.elit\",numRows = 12) == \"Laso.micrtepieitinms.dg..ca.iro.eponrlslsuiuoettmdce.t\"\n    assert candidate(s = \"ABCD\",numRows = 1) == \"ABCD\"\n    assert candidate(s = \"ZigzagPatternConversionIsCool.\",numRows = 7) == \"ZnsirCICgeonoztnooatvilgaes.Pr\"\n    assert candidate(s = \"ZIGZAGCONVERSION\",numRows = 6) == \"ZEIVRGNSZOIACOGN\"\n    assert candidate(s = \".,,..,.\",numRows = 3) == \"..,.,,.\"\n    assert candidate(s = \"1234567890\",numRows = 2) == \"1357924680\"\n    assert candidate(s = \"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.\",numRows = 12) == \"alw.....bkmvx.....cjnuy.....diotz.....ehps....fgqr..\"\n    assert candidate(s = \"HELLOALLOHELLOALLOHELLOALLO\",numRows = 2) == \"HLOLOELALHLOLOELALHLOLOELAL\"\n    assert candidate(s = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",numRows = 10) == \"asKbrtJLcquIMdpvHNZeowGOYfnxFPXgmyEQWhlzDRVikACSUjBT\"\n    assert candidate(s = \"AnotherExampleWithALongerStringThatShouldBeChallengingToFormatCorrectly\",numRows = 8) == \"AWieFyneirnBCoololttgdhTrttphSTlagmchmArhulnaeeaLeaolitrrxogthegCrEnSno\"\n    assert candidate(s = \"A\",numRows = 5) == \"A\"\n    assert candidate(s = \"SHORT\",numRows = 25) == \"SHORT\"\n    assert candidate(s = \"Zigzag.patters.are.pretty.cool.and.fascinating\",numRows = 10) == \"Z.aiepfsgrr.czaedia.tnngstaa.ry.tpe.liatcontog\"\n    assert candidate(s = \"ZigZagConversion\",numRows = 6) == \"ZeivrgnsZoiaCogn\"\n    assert candidate(s = \"PYTHONISAWESOMELANGUAGEFORTACKLINGCOMPLEXPROBLEMS\",numRows = 6) == \"PEALXYWSUGKIEPTAOGECNLRSHSMNFAGPOMOIEAOTCMBENLROL\"\n    assert candidate(s = \"PYTHONPROGRAMMING\",numRows = 5) == \"POGYRGNTPRIHNAMOM\"\n    assert candidate(s = \"BUTTERTOOMELON\",numRows = 3) == \"BEOOUTROMLNTTE\"\n    assert candidate(s = \"1234567890abcdefghijklmnopqrstuvwxyz\",numRows = 7) == \"1co2bdnpz3aemqy40flrx59gksw68hjtv7iu\"\n    assert candidate(s = \"ZIGZAGCONVERSION\",numRows = 8) == \"ZOIINGSZRAEGVCNO\"\n    assert candidate(s = \"HELLOPYTHONHELLOPYTHONHELLOPYTHONHELLOPYTHON\",numRows = 8) == \"HLYOELOPTHNLEPOHTLHYLOYONTLNPPOHEHOYHOHELTNL\"\n    assert candidate(s = \"A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z.\",numRows = 5) == \"AEIMQUY.............BDFHJLNPRTVXZ.............CGKOSW\"\n    assert candidate(s = \"ALGORITHMSANDDATASTRUCTURES\",numRows = 8) == \"AALDTGDASONSERATRISRUTMUTHC\"\n    assert candidate(s = \"A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z.\",numRows = 10) == \"AJS.....BIKRT......CHLQUZ......DGMPVY......EFNOWX...\"\n    assert candidate(s = \"A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z.\",numRows = 6) == \"AFKPUZ...........BEGJLOQTVY..........CDHIMNRSWX.....\"\n    assert candidate(s = \"ToCodeOrNotToCode.\",numRows = 2) == \"TCdONtooeooeroTCd.\"\n    assert candidate(s = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",numRows = 11) == \"auObtvNPcswMQdrxLReqyKSfpzJTgoAIUhnBHVimCGWjlDFXZkEY\"\n    assert candidate(s = \"HELLO.WORLD.THIS.IS.A.TEST\",numRows = 8) == \"HIEHSLT.L.ITODSS.L.EWRATO.\"\n    assert candidate(s = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",numRows = 6) == \"Lmtna ou i os dgersdsacerinlepo m cupiimilre,ttict otes.\"\n    assert candidate(s = \"Longer.string.for.testing.the.zigzag.conversion\",numRows = 2) == \"Lne.tigfrtsigtezga.ovrinogrsrn.o.etn.h.izgcneso\"\n    assert candidate(s = \"THISISAMUCHLONGERSTRINGTHANTHEPREVIOUSONES\",numRows = 9) == \"TREHESRVIGTPISNREOIOIHUSLNTSAHGNOMCTANSUHE\"\n    assert candidate(s = \"REPEATEREPEATEREPEATEREPEATEREPEAT\",numRows = 15) == \"RREEEPTPEAEAEATPTEERREEPTEAAETPEER\"\n    assert candidate(s = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",numRows = 12) == \"1Mi2LNhj3KOgk4JPfl5IQem6HRdnz7GScoy8FTbpx9EUaqw0DVZrvACWYsuBXt\"\n    assert candidate(s = \"HELLOWORLDTHISISATEST\",numRows = 7) == \"HIEHSLTILDSOLATWRTSOE\"\n    assert candidate(s = \"AQuickBrownFoxJumpsOverTheLazyDog\",numRows = 11) == \"AvQOeusripTcmhkueBJLrxaoozgwFyonD\"\n    assert candidate(s = \"123456789012345678901234567890\",numRows = 5) == \"197528068463715937462402805319\"\n    assert candidate(s = \"........................................\",numRows = 4) == \"........................................\"\n    assert candidate(s = \"ThisIsALongStringToTestTheFunctionalityOfTheZigZagConversion\",numRows = 7) == \"TthiahSrTeltZgnigitFaygCosnnsunOioiIogenofZnssLTTciTevrAothe\"\n    assert candidate(s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",numRows = 8) == \"AOBNPCMQDLRZEKSYFJTXGIUWHV\"\n    assert candidate(s = \"HELLO.,WORLD.,HELLO.,WORLD.,HELLO.,WORLD.\",numRows = 10) == \"HOOEL.WRLL,,LLEW.DOHOO..,RL,.LLWDDEOL.HR,\"\n    assert candidate(s = \"Short.string\",numRows = 1) == \"Short.string\"\n    assert candidate(s = \"THISISALONGSTRINGFORTHETESTCASE\",numRows = 7) == \"TTEHSRTSIGIETSNNHCIOGTASLFRSAOE\"\n    assert candidate(s = \"12345678901234567890\",numRows = 10) == \"19280374655647382910\"\n    assert candidate(s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\",numRows = 7) == \"AMYBLNXZ9CKOW08DJPV17EIQU26FHRT35GS4\"\n    assert candidate(s = \"ONETWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE,TEN\",numRows = 12) == \"O,TNES,EEVIENTIXNWF,IO,SN,RE,TUVTHOEHRFNGE,,IEE\"\n    assert candidate(s = \"THEQUICK.BROWN.FOX.JUMPS.OVER.THE.LAZY.DOG.\",numRows = 5) == \"T.O.EOHKBFXSOH.DGECR..PVTL..QIONJME.AYUWURZ\"\n    assert candidate(s = \"ALGORITHMSAREFUN\",numRows = 6) == \"AALSRGMEOHFRTUIN\"\n    assert candidate(s = \"123456789012345678901234567890\",numRows = 6) == \"111202020393939484848575757666\"\n    assert candidate(s = \"This.is.a.test.string\",numRows = 5) == \"Tath..srist.isietn.sg\"\n    assert candidate(s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\",numRows = 12) == \"AWSBVXRTCUYQUDTZPVESAOWFRBNXGQCMYHPDLZIOEKJNFJKMGILH\"\n    assert candidate(s = \"AQUICKMOVEMENTOFTHEBROWNFOX\",numRows = 9) == \"ATQFHUOEITBCNRKEOMMWXOENOVF\"\n    assert candidate(s = \"OneTwoThreeFourFiveSixSevenEightNineTenElevenTwelveThirteenFourteenFifteen\",numRows = 9) == \"OiNlenFvtievteerehnwernTuSgeTTuFwoiiTnhoioFxEeeiFfTeSnnvrntheeeEeteenrvlee\"\n    assert candidate(s = \"abcdefghijklmnopqrstuvwxyz\",numRows = 13) == \"aybxzcwdveuftgshriqjpkolnm\"\n    assert candidate(s = \"AVERYLONGSTRINGTHATWILLBETESTEDTOENSURETHECORRECTNESSOFTHETEST\",numRows = 20) == \"AEVRTEUHRSEYNCLEOOORNTRGDESECTTTRSNIEENTSGESTBOTHLFSALTETIHTWE\"\n    assert candidate(s = \"Python.is.awesome.and.fun\",numRows = 9) == \"Peym.toahsnoednw..afi.usn\"\n    assert candidate(s = \"\",numRows = 3) == \"\"\n    assert candidate(s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\",numRows = 5) == \"AIQYBHJPRXZCGKOSW.DFLNTV,EMU\"\n    assert candidate(s = \"PythonIsFun\",numRows = 5) == \"PFysutInhno\"\n    assert candidate(s = \"COMPLEXTESTCASEWITHVARYINGCHARS,.,\",numRows = 9) == \"CI.OWT,,MEHSPSVRLAAAECRHXTYCTSIGEN\"\n    assert candidate(s = \"Mississippi\",numRows = 2) == \"Msispiissip\"\n    assert candidate(s = \"PythonProgrammingIsFunAndEducational!\",numRows = 7) == \"Pmd!yamnEltriAdahgnnunooguconrIFaiPst\"\n    assert candidate(s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",numRows = 10) == \"ASBRTCQUDPVEOWFNXGMYHLZIKJ\"\n    assert candidate(s = \"zigzagzigzagzigzagzigzagzigzagzigzagzigzag\",numRows = 4) == \"zzzzzzzigigigigigigiggagagagagagagazzzzzzz\"\n    assert candidate(s = \"SOMETIMESGOODPROGRAMSMAKEYOUCRY\",numRows = 2) == \"SMTMSODRGASAEOCYOEIEGOPORMMKYUR\"\n    assert candidate(s = \"REPEATEDCHARACTERSTESTCASEEEEEEEEEEEEEEEEEEEEEE\",numRows = 15) == \"REEEEPEEEEEASETAEECEDTECSEHEEATEERSEEAREECEEETE\"\n    assert candidate(s = \"TheQuickBrownFoxJumpsOverTheLazyDog\",numRows = 6) == \"ToszhrwpOayeBnmvLDQkFueeoucoJrhgixT\"\n    assert candidate(s = \"HELLO.,WORLD.,HELLO.,WORLD.\",numRows = 5) == \"HOLLEWRELRDL,LHOO.L.D,.WO.,\"\n    assert candidate(s = \"AABBAABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ\",numRows = 12) == \"AJUAIJTUBIKTVBHKSVAHLSWAGLRWBGMRXBFMQXCFNQYCENPYDEOPZDOZ\"\n    assert candidate(s = \"PYTHON.IS.A.GREAT.LANGUAGE.\",numRows = 4) == \"P.GLGYNI.R.AAETOSAETNU.H.AG\"\n    assert candidate(s = \"MULTIPLELINESAREHERE.FIXEDFONTISNEAT.\",numRows = 15) == \"MNUOTLFITDSIENPXELIAEFTL..IENREESHAER\"\n    assert candidate(s = \"MixedCASEAndNumbers123\",numRows = 4) == \"MANsiCSdur1xdEnme2eAb3\"\n    assert candidate(s = \"PythonIsFunAndChallenging\",numRows = 5) == \"PFagysuhlntInClihnAdegonn\"\n    assert candidate(s = \"S.P.E.C.I.A.L.,C.H.A.R.A.C.T.E.R.S.\",numRows = 9) == \"S...CHRSP,.....AEEL....RTCA....ACI.\"\n    assert candidate(s = \"OneMoreExampleHere\",numRows = 10) == \"OneerMeoHreelEpxma\"\n", "input_output": [{"input": "s = \"PAYPALISHIRING\", numRows = 4", "output": "PINALSIGYAHRPI"}, {"input": "s = \"ABCDEFGHI\", numRows = 3", "output": "AEIBDFHCG"}, {"input": "s = \"A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z\", numRows = 5", "output": "AEIMQUY,,,,,,,,,,,,,BDFHJLNPRTVXZ,,,,,,,,,,,,CGKOSW"}, {"input": "s = \"PAYPALISHIRING\", numRows = 3", "output": "PAHNAPLSIIGYIR"}, {"input": "s = \"A\", numRows = 1", "output": "A"}, {"input": "s = \"HELLO\", numRows = 5", "output": "HELLO"}, {"input": "s = \"ABCDEF\", numRows = 2", "output": "ACEBDF"}, {"input": "s = \"HELLO WORLD\", numRows = 5", "output": "HREOLLWDL O"}, {"input": "s = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z\", numRows = 20", "output": "atM,,,,,bsuLN,,,,,crvKO,,,,,dqwJP,,,,,epxIQ,,,,,foyHR,,,,,gnzGSZ,,,,,,hmAFTY,,,,,,ilBEUX,,,,,,jkCDVW,,,"}, {"input": "s = \"AB\", numRows = 1", "output": "AB"}, {"input": "s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", numRows = 5", "output": "AIQYBHJPRXZCGKOSWDFLNTVEMU"}, {"input": "s = \"ABCD\", numRows = 2", "output": "ACBD"}, {"input": "s = \"ABCDEFGHIJKL\", numRows = 4", "output": "AGBFHLCEIKDJ"}, {"input": "s = \"HELLO.WORLD.\", numRows = 3", "output": "HOREL.OL.LWD"}, {"input": "s = \"ABC\", numRows = 2", "output": "ACB"}, {"input": "s = \"ABCDEFG\", numRows = 1", "output": "ABCDEFG"}, {"input": "s = \"A,B.C\", numRows = 3", "output": "AC,.B"}, {"input": "s = \"A,B,C,D,E,F,G\", numRows = 3", "output": "ACEG,,,,,,BDF"}, {"input": "s = \"ABCDEFGHIJKL\", numRows = 3", "output": "AEIBDFHJLCGK"}, {"input": "s = \"\", numRows = 1", "output": ""}, {"input": "s = \"COMPLEX.EXAMPLE\", numRows = 6", "output": "CAOXMMEPP.LLXEE"}, {"input": "s = \"A,B,C.,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z.\", numRows = 7", "output": "A,,,,,FGLMRSXYB,,,,,,,,,EHKNQTWZC,,,,,,,..DIJOPUV,,,,"}, {"input": "s = \"..............................\", numRows = 10", "output": ".............................."}, {"input": "s = \"ZIGZAG\", numRows = 6", "output": "ZIGZAG"}, {"input": "s = \"ThisIsATestOfTheEmergencyBroadcastSystem\", numRows = 10", "output": "TeshmrytiEgSeseetmIhnssTcaAfycTOBdetraso"}, {"input": "s = \"The quick brown fox jumps over the lazy dog.\", numRows = 3", "output": "Tqkofjsehadh uc rw o up vrtelz o.eibnxmo  yg"}, {"input": "s = \"WithSpecialCharacters!@#$%^&*()\", numRows = 5", "output": "Wic$icaat#%telre@^)hpCar!&(Shs*"}, {"input": "s = \"The quick brown fox jumps over the lazy dog.\", numRows = 8", "output": "Tneghw vro.eofo d ro t qbxshyu  pezikjm acul"}, {"input": "s = \"This,is,a,longer,string,with,punctuation!\", numRows = 7", "output": "Tnwthog,iaiilegtuos,rnhtn,a,i,c!i,srpnstu"}, {"input": "s = \"\", numRows = 5", "output": ""}, {"input": "s = \"Short\", numRows = 1", "output": "Short"}, {"input": "s = \"Lorem.ipsum.dolor.sit.amet.consectetur.adipiscing.elit\", numRows = 12", "output": "Laso.micrtepieitinms.dg..ca.iro.eponrlslsuiuoettmdce.t"}, {"input": "s = \"ABCD\", numRows = 1", "output": "ABCD"}, {"input": "s = \"ZigzagPatternConversionIsCool.\", numRows = 7", "output": "ZnsirCICgeonoztnooatvilgaes.Pr"}, {"input": "s = \"ZIGZAGCONVERSION\", numRows = 6", "output": "ZEIVRGNSZOIACOGN"}, {"input": "s = \".,,..,.\", numRows = 3", "output": "..,.,,."}, {"input": "s = \"1234567890\", numRows = 2", "output": "1357924680"}, {"input": "s = \"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.\", numRows = 12", "output": "alw.....bkmvx.....cjnuy.....diotz.....ehps....fgqr.."}, {"input": "s = \"HELLOALLOHELLOALLOHELLOALLO\", numRows = 2", "output": "HLOLOELALHLOLOELALHLOLOELAL"}, {"input": "s = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", numRows = 10", "output": "asKbrtJLcquIMdpvHNZeowGOYfnxFPXgmyEQWhlzDRVikACSUjBT"}, {"input": "s = \"AnotherExampleWithALongerStringThatShouldBeChallengingToFormatCorrectly\", numRows = 8", "output": "AWieFyneirnBCoololttgdhTrttphSTlagmchmArhulnaeeaLeaolitrrxogthegCrEnSno"}, {"input": "s = \"A\", numRows = 5", "output": "A"}, {"input": "s = \"SHORT\", numRows = 25", "output": "SHORT"}, {"input": "s = \"Zigzag.patters.are.pretty.cool.and.fascinating\", numRows = 10", "output": "Z.aiepfsgrr.czaedia.tnngstaa.ry.tpe.liatcontog"}, {"input": "s = \"ZigZagConversion\", numRows = 6", "output": "ZeivrgnsZoiaCogn"}, {"input": "s = \"PYTHONISAWESOMELANGUAGEFORTACKLINGCOMPLEXPROBLEMS\", numRows = 6", "output": "PEALXYWSUGKIEPTAOGECNLRSHSMNFAGPOMOIEAOTCMBENLROL"}, {"input": "s = \"PYTHONPROGRAMMING\", numRows = 5", "output": "POGYRGNTPRIHNAMOM"}, {"input": "s = \"BUTTERTOOMELON\", numRows = 3", "output": "BEOOUTROMLNTTE"}, {"input": "s = \"1234567890abcdefghijklmnopqrstuvwxyz\", numRows = 7", "output": "1co2bdnpz3aemqy40flrx59gksw68hjtv7iu"}, {"input": "s = \"ZIGZAGCONVERSION\", numRows = 8", "output": "ZOIINGSZRAEGVCNO"}, {"input": "s = \"HELLOPYTHONHELLOPYTHONHELLOPYTHONHELLOPYTHON\", numRows = 8", "output": "HLYOELOPTHNLEPOHTLHYLOYONTLNPPOHEHOYHOHELTNL"}, {"input": "s = \"A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z.\", numRows = 5", "output": "AEIMQUY.............BDFHJLNPRTVXZ.............CGKOSW"}, {"input": "s = \"ALGORITHMSANDDATASTRUCTURES\", numRows = 8", "output": "AALDTGDASONSERATRISRUTMUTHC"}, {"input": "s = \"A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z.\", numRows = 10", "output": "AJS.....BIKRT......CHLQUZ......DGMPVY......EFNOWX..."}, {"input": "s = \"A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z.\", numRows = 6", "output": "AFKPUZ...........BEGJLOQTVY..........CDHIMNRSWX....."}, {"input": "s = \"ToCodeOrNotToCode.\", numRows = 2", "output": "TCdONtooeooeroTCd."}, {"input": "s = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", numRows = 11", "output": "auObtvNPcswMQdrxLReqyKSfpzJTgoAIUhnBHVimCGWjlDFXZkEY"}, {"input": "s = \"HELLO.WORLD.THIS.IS.A.TEST\", numRows = 8", "output": "HIEHSLT.L.ITODSS.L.EWRATO."}, {"input": "s = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\", numRows = 6", "output": "Lmtna ou i os dgersdsacerinlepo m cupiimilre,ttict otes."}, {"input": "s = \"Longer.string.for.testing.the.zigzag.conversion\", numRows = 2", "output": "Lne.tigfrtsigtezga.ovrinogrsrn.o.etn.h.izgcneso"}, {"input": "s = \"THISISAMUCHLONGERSTRINGTHANTHEPREVIOUSONES\", numRows = 9", "output": "TREHESRVIGTPISNREOIOIHUSLNTSAHGNOMCTANSUHE"}, {"input": "s = \"REPEATEREPEATEREPEATEREPEATEREPEAT\", numRows = 15", "output": "RREEEPTPEAEAEATPTEERREEPTEAAETPEER"}, {"input": "s = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", numRows = 12", "output": "1Mi2LNhj3KOgk4JPfl5IQem6HRdnz7GScoy8FTbpx9EUaqw0DVZrvACWYsuBXt"}, {"input": "s = \"HELLOWORLDTHISISATEST\", numRows = 7", "output": "HIEHSLTILDSOLATWRTSOE"}, {"input": "s = \"AQuickBrownFoxJumpsOverTheLazyDog\", numRows = 11", "output": "AvQOeusripTcmhkueBJLrxaoozgwFyonD"}, {"input": "s = \"123456789012345678901234567890\", numRows = 5", "output": "197528068463715937462402805319"}, {"input": "s = \"........................................\", numRows = 4", "output": "........................................"}, {"input": "s = \"ThisIsALongStringToTestTheFunctionalityOfTheZigZagConversion\", numRows = 7", "output": "TthiahSrTeltZgnigitFaygCosnnsunOioiIogenofZnssLTTciTevrAothe"}, {"input": "s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", numRows = 8", "output": "AOBNPCMQDLRZEKSYFJTXGIUWHV"}, {"input": "s = \"HELLO.,WORLD.,HELLO.,WORLD.,HELLO.,WORLD.\", numRows = 10", "output": "HOOEL.WRLL,,LLEW.DOHOO..,RL,.LLWDDEOL.HR,"}, {"input": "s = \"Short.string\", numRows = 1", "output": "Short.string"}, {"input": "s = \"THISISALONGSTRINGFORTHETESTCASE\", numRows = 7", "output": "TTEHSRTSIGIETSNNHCIOGTASLFRSAOE"}, {"input": "s = \"12345678901234567890\", numRows = 10", "output": "19280374655647382910"}, {"input": "s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", numRows = 7", "output": "AMYBLNXZ9CKOW08DJPV17EIQU26FHRT35GS4"}, {"input": "s = \"ONETWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE,TEN\", numRows = 12", "output": "O,TNES,EEVIENTIXNWF,IO,SN,RE,TUVTHOEHRFNGE,,IEE"}, {"input": "s = \"THEQUICK.BROWN.FOX.JUMPS.OVER.THE.LAZY.DOG.\", numRows = 5", "output": "T.O.EOHKBFXSOH.DGECR..PVTL..QIONJME.AYUWURZ"}, {"input": "s = \"ALGORITHMSAREFUN\", numRows = 6", "output": "AALSRGMEOHFRTUIN"}, {"input": "s = \"123456789012345678901234567890\", numRows = 6", "output": "111202020393939484848575757666"}, {"input": "s = \"This.is.a.test.string\", numRows = 5", "output": "Tath..srist.isietn.sg"}, {"input": "s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\", numRows = 12", "output": "AWSBVXRTCUYQUDTZPVESAOWFRBNXGQCMYHPDLZIOEKJNFJKMGILH"}, {"input": "s = \"AQUICKMOVEMENTOFTHEBROWNFOX\", numRows = 9", "output": "ATQFHUOEITBCNRKEOMMWXOENOVF"}, {"input": "s = \"OneTwoThreeFourFiveSixSevenEightNineTenElevenTwelveThirteenFourteenFifteen\", numRows = 9", "output": "OiNlenFvtievteerehnwernTuSgeTTuFwoiiTnhoioFxEeeiFfTeSnnvrntheeeEeteenrvlee"}, {"input": "s = \"abcdefghijklmnopqrstuvwxyz\", numRows = 13", "output": "aybxzcwdveuftgshriqjpkolnm"}, {"input": "s = \"AVERYLONGSTRINGTHATWILLBETESTEDTOENSURETHECORRECTNESSOFTHETEST\", numRows = 20", "output": "AEVRTEUHRSEYNCLEOOORNTRGDESECTTTRSNIEENTSGESTBOTHLFSALTETIHTWE"}, {"input": "s = \"Python.is.awesome.and.fun\", numRows = 9", "output": "Peym.toahsnoednw..afi.usn"}, {"input": "s = \"\", numRows = 3", "output": ""}, {"input": "s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\", numRows = 5", "output": "AIQYBHJPRXZCGKOSW.DFLNTV,EMU"}, {"input": "s = \"PythonIsFun\", numRows = 5", "output": "PFysutInhno"}, {"input": "s = \"COMPLEXTESTCASEWITHVARYINGCHARS,.,\", numRows = 9", "output": "CI.OWT,,MEHSPSVRLAAAECRHXTYCTSIGEN"}, {"input": "s = \"Mississippi\", numRows = 2", "output": "Msispiissip"}, {"input": "s = \"PythonProgrammingIsFunAndEducational!\", numRows = 7", "output": "Pmd!yamnEltriAdahgnnunooguconrIFaiPst"}, {"input": "s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", numRows = 10", "output": "ASBRTCQUDPVEOWFNXGMYHLZIKJ"}, {"input": "s = \"zigzagzigzagzigzagzigzagzigzagzigzagzigzag\", numRows = 4", "output": "zzzzzzzigigigigigigiggagagagagagagazzzzzzz"}, {"input": "s = \"SOMETIMESGOODPROGRAMSMAKEYOUCRY\", numRows = 2", "output": "SMTMSODRGASAEOCYOEIEGOPORMMKYUR"}, {"input": "s = \"REPEATEDCHARACTERSTESTCASEEEEEEEEEEEEEEEEEEEEEE\", numRows = 15", "output": "REEEEPEEEEEASETAEECEDTECSEHEEATEERSEEAREECEEETE"}, {"input": "s = \"TheQuickBrownFoxJumpsOverTheLazyDog\", numRows = 6", "output": "ToszhrwpOayeBnmvLDQkFueeoucoJrhgixT"}, {"input": "s = \"HELLO.,WORLD.,HELLO.,WORLD.\", numRows = 5", "output": "HOLLEWRELRDL,LHOO.L.D,.WO.,"}, {"input": "s = \"AABBAABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ\", numRows = 12", "output": "AJUAIJTUBIKTVBHKSVAHLSWAGLRWBGMRXBFMQXCFNQYCENPYDEOPZDOZ"}, {"input": "s = \"PYTHON.IS.A.GREAT.LANGUAGE.\", numRows = 4", "output": "P.GLGYNI.R.AAETOSAETNU.H.AG"}, {"input": "s = \"MULTIPLELINESAREHERE.FIXEDFONTISNEAT.\", numRows = 15", "output": "MNUOTLFITDSIENPXELIAEFTL..IENREESHAER"}, {"input": "s = \"MixedCASEAndNumbers123\", numRows = 4", "output": "MANsiCSdur1xdEnme2eAb3"}, {"input": "s = \"PythonIsFunAndChallenging\", numRows = 5", "output": "PFagysuhlntInClihnAdegonn"}, {"input": "s = \"S.P.E.C.I.A.L.,C.H.A.R.A.C.T.E.R.S.\", numRows = 9", "output": "S...CHRSP,.....AEEL....RTCA....ACI."}, {"input": "s = \"OneMoreExampleHere\", numRows = 10", "output": "OneerMeoHreelEpxma"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n \nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n\n \nConstraints:\n\n1 <= s.length <= 1000\ns consists of English letters (lower-case and upper-case), ',' and '.'.\n1 <= numRows <= 1000\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        \n        # Create a list of strings for each row\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n        \n        for char in s:\n            rows[current_row] += char\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n            current_row += 1 if going_down else -1\n        \n        # Join all rows to get the final string\n        return ''.join(rows)\n```\n\nThis solution handles the zigzag conversion by iterating through each character in the string `s` and appending it to the appropriate row in the `rows` list. The `current_row` variable keeps track of the current row, and the `going_down` boolean flag determines the direction of traversal (down or up). After processing all characters, the rows are concatenated to produce the final result."}
{"task_id": "reverse-integer", "question_id": 7, "difficulty": "Medium", "tags": ["Math"], "problem_description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n \nExample 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21\n\n \nConstraints:\n\n-231 <= x <= 231 - 1\n\n", "starter_code": "class Solution:\n    def reverse(self, x: int) -> int:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def reverse(self, x: int) -> int:\n        ans = 0\n        mi, mx = -(2**31), 2**31 - 1\n        while x:\n            if ans < mi // 10 + 1 or ans > mx // 10:\n                return 0\n            y = x % 10\n            if x < 0 and y > 0:\n                y -= 10\n            ans = ans * 10 + y\n            x = (x - y) // 10\n        return ans\n", "entry_point": "Solution().reverse", "test": "def check(candidate):\n    assert candidate(x = -2147483412) == -2143847412\n    assert candidate(x = 2147483647) == 0\n    assert candidate(x = 120) == 21\n    assert candidate(x = -123) == -321\n    assert candidate(x = 1534236469) == 0\n    assert candidate(x = 0) == 0\n    assert candidate(x = -2147483648) == 0\n    assert candidate(x = -1534236469) == 0\n    assert candidate(x = 123) == 321\n    assert candidate(x = -10) == -1\n    assert candidate(x = -100000) == -1\n    assert candidate(x = 10) == 1\n    assert candidate(x = -999999999) == -999999999\n    assert candidate(x = 1) == 1\n    assert candidate(x = 2147483646) == 0\n    assert candidate(x = -123000) == -321\n    assert candidate(x = -900000) == -9\n    assert candidate(x = -100100100) == -1001001\n    assert candidate(x = -2147483647) == 0\n    assert candidate(x = -1010101010) == -101010101\n    assert candidate(x = 1000000001) == 1000000001\n    assert candidate(x = -1) == -1\n    assert candidate(x = 123000) == 321\n    assert candidate(x = -2000000002) == -2000000002\n    assert candidate(x = 101010101) == 101010101\n    assert candidate(x = 1111111111) == 1111111111\n    assert candidate(x = 2147447412) == 2147447412\n    assert candidate(x = -101010101) == -101010101\n    assert candidate(x = 900000) == 9\n    assert candidate(x = 987654321) == 123456789\n    assert candidate(x = 999999999) == 999999999\n    assert candidate(x = -1000000000) == -1\n    assert candidate(x = 1001001001) == 1001001001\n    assert candidate(x = -987654321) == -123456789\n    assert candidate(x = -1000000001) == -1000000001\n    assert candidate(x = 10000000000) == 1\n    assert candidate(x = 11000000001) == 0\n    assert candidate(x = 876543210) == 12345678\n    assert candidate(x = 2147483640) == 463847412\n    assert candidate(x = 100100100) == 1001001\n    assert candidate(x = 100000) == 1\n    assert candidate(x = 2000000002) == 2000000002\n    assert candidate(x = -9646324351) == -1534236469\n    assert candidate(x = -123456789) == -987654321\n    assert candidate(x = 7463847412) == 2147483647\n    assert candidate(x = -1000000003) == 0\n    assert candidate(x = -3000000001) == -1000000003\n    assert candidate(x = -876543210) == -12345678\n    assert candidate(x = -1111111111) == -1111111111\n    assert candidate(x = -1001001001) == -1001001001\n    assert candidate(x = 9646324351) == 1534236469\n    assert candidate(x = 1010101010) == 101010101\n    assert candidate(x = 123456789) == 987654321\n    assert candidate(x = -10000000000) == -1\n    assert candidate(x = -2147483640) == -463847412\n    assert candidate(x = -7463847412) == -2147483647\n    assert candidate(x = 3000000001) == 1000000003\n    assert candidate(x = 1000000000) == 1\n    assert candidate(x = 1000000003) == 0\n    assert candidate(x = -214748364) == -463847412\n    assert candidate(x = 9000000000) == 9\n", "input_output": [{"input": "x = -2147483412", "output": "-2143847412"}, {"input": "x = 2147483647", "output": "0"}, {"input": "x = 120", "output": "21"}, {"input": "x = -123", "output": "-321"}, {"input": "x = 1534236469", "output": "0"}, {"input": "x = 0", "output": "0"}, {"input": "x = -2147483648", "output": "0"}, {"input": "x = -1534236469", "output": "0"}, {"input": "x = 123", "output": "321"}, {"input": "x = -10", "output": "-1"}, {"input": "x = -100000", "output": "-1"}, {"input": "x = 10", "output": "1"}, {"input": "x = -999999999", "output": "-999999999"}, {"input": "x = 1", "output": "1"}, {"input": "x = 2147483646", "output": "0"}, {"input": "x = -123000", "output": "-321"}, {"input": "x = -900000", "output": "-9"}, {"input": "x = -100100100", "output": "-1001001"}, {"input": "x = -2147483647", "output": "0"}, {"input": "x = -1010101010", "output": "-101010101"}, {"input": "x = 1000000001", "output": "1000000001"}, {"input": "x = -1", "output": "-1"}, {"input": "x = 123000", "output": "321"}, {"input": "x = -2000000002", "output": "-2000000002"}, {"input": "x = 101010101", "output": "101010101"}, {"input": "x = 1111111111", "output": "1111111111"}, {"input": "x = 2147447412", "output": "2147447412"}, {"input": "x = -101010101", "output": "-101010101"}, {"input": "x = 900000", "output": "9"}, {"input": "x = 987654321", "output": "123456789"}, {"input": "x = 999999999", "output": "999999999"}, {"input": "x = -1000000000", "output": "-1"}, {"input": "x = 1001001001", "output": "1001001001"}, {"input": "x = -987654321", "output": "-123456789"}, {"input": "x = -1000000001", "output": "-1000000001"}, {"input": "x = 10000000000", "output": "1"}, {"input": "x = 11000000001", "output": "0"}, {"input": "x = 876543210", "output": "12345678"}, {"input": "x = 2147483640", "output": "463847412"}, {"input": "x = 100100100", "output": "1001001"}, {"input": "x = 100000", "output": "1"}, {"input": "x = 2000000002", "output": "2000000002"}, {"input": "x = -9646324351", "output": "-1534236469"}, {"input": "x = -123456789", "output": "-987654321"}, {"input": "x = 7463847412", "output": "2147483647"}, {"input": "x = -1000000003", "output": "0"}, {"input": "x = -3000000001", "output": "-1000000003"}, {"input": "x = -876543210", "output": "-12345678"}, {"input": "x = -1111111111", "output": "-1111111111"}, {"input": "x = -1001001001", "output": "-1001001001"}, {"input": "x = 9646324351", "output": "1534236469"}, {"input": "x = 1010101010", "output": "101010101"}, {"input": "x = 123456789", "output": "987654321"}, {"input": "x = -10000000000", "output": "-1"}, {"input": "x = -2147483640", "output": "-463847412"}, {"input": "x = -7463847412", "output": "-2147483647"}, {"input": "x = 3000000001", "output": "1000000003"}, {"input": "x = 1000000000", "output": "1"}, {"input": "x = 1000000003", "output": "0"}, {"input": "x = -214748364", "output": "-463847412"}, {"input": "x = 9000000000", "output": "9"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n \nExample 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21\n\n \nConstraints:\n\n-231 <= x <= 231 - 1\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def reverse(self, x: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nclass Solution:\n    def reverse(self, x: int) -> int:\n        # Determine the sign of the number\n        sign = -1 if x < 0 else 1\n        \n        # Reverse the digits of the absolute value of the number\n        reversed_digits = int(str(abs(x))[::-1])\n        \n        # Restore the sign\n        reversed_number = sign * reversed_digits\n        \n        # Check if the reversed number is within the 32-bit signed integer range\n        if reversed_number < -2**31 or reversed_number > 2**31 - 1:\n            return 0\n        \n        return reversed_number\n```"}
{"task_id": "string-to-integer-atoi", "question_id": 8, "difficulty": "Medium", "tags": ["String"], "problem_description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\nThe algorithm for myAtoi(string s) is as follows:\n\nWhitespace: Ignore any leading whitespace (\" \").\nSignedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.\nConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\nRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\n\nReturn the integer as the final result.\n \nExample 1:\n\nInput: s = \"42\"\nOutput: 42\nExplanation:\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\n\n\nExample 2:\n\nInput: s = \" -042\"\nOutput: -42\nExplanation:\n\nStep 1: \"   -042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -042\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\nExample 3:\n\nInput: s = \"1337c0d3\"\nOutput: 1337\nExplanation:\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\nExample 4:\n\nInput: s = \"0-1\"\nOutput: 0\nExplanation:\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\nExample 5:\n\nInput: s = \"words and 987\"\nOutput: 0\nExplanation:\nReading stops at the first non-digit character 'w'.\n\n \nConstraints:\n\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\n\n", "starter_code": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        if not s:\n            return 0\n        n = len(s)\n        if n == 0:\n            return 0\n        i = 0\n        while s[i] == ' ':\n            i += 1\n            # 仅包含空格\n            if i == n:\n                return 0\n        sign = -1 if s[i] == '-' else 1\n        if s[i] in ['-', '+']:\n            i += 1\n        res, flag = 0, (2**31 - 1) // 10\n        while i < n:\n            # 非数字，跳出循环体\n            if not s[i].isdigit():\n                break\n            c = int(s[i])\n            # 溢出判断\n            if res > flag or (res == flag and c > 7):\n                return 2**31 - 1 if sign > 0 else -(2**31)\n            res = res * 10 + c\n            i += 1\n        return sign * res\n", "entry_point": "Solution().myAtoi", "test": "def check(candidate):\n    assert candidate(s = \"2147483647\") == 2147483647\n    assert candidate(s = \"42 with words\") == 42\n    assert candidate(s = \"20000000000000000000000000000000000000000\") == 2147483647\n    assert candidate(s = \"-2147483649\") == -2147483648\n    assert candidate(s = \"-21474836480\") == -2147483648\n    assert candidate(s = \"  000000000000   \") == 0\n    assert candidate(s = \"+1\") == 1\n    assert candidate(s = \"   -  42\") == 0\n    assert candidate(s = \"words with 42\") == 0\n    assert candidate(s = \"   -042\") == -42\n    assert candidate(s = \"0-1\") == 0\n    assert candidate(s = \"   0\") == 0\n    assert candidate(s = \"-5\") == -5\n    assert candidate(s = \"      -119197303367810844   \") == -2147483648\n    assert candidate(s = \"   -12345\") == -12345\n    assert candidate(s = \" \") == 0\n    assert candidate(s = \" -042\") == -42\n    assert candidate(s = \"    -88827   5655  U\") == -88827\n    assert candidate(s = \"+-12\") == 0\n    assert candidate(s = \"   +0 123\") == 0\n    assert candidate(s = \"+2\") == 2\n    assert candidate(s = \"   +0 91283472332\") == 0\n    assert candidate(s = \"   - 42\") == 0\n    assert candidate(s = \"words and 987\") == 0\n    assert candidate(s = \"3.14159\") == 3\n    assert candidate(s = \"   20000000000000000000\") == 2147483647\n    assert candidate(s = \"0000000000012345678\") == 12345678\n    assert candidate(s = \".\") == 0\n    assert candidate(s = \"2147483648\") == 2147483647\n    assert candidate(s = \"\") == 0\n    assert candidate(s = \"    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\") == 0\n    assert candidate(s = \"-\") == 0\n    assert candidate(s = \"42\") == 42\n    assert candidate(s = \"-91283472332\") == -2147483648\n    assert candidate(s = \"4193 with words\") == 4193\n    assert candidate(s = \"   3.14159\") == 3\n    assert candidate(s = \"  +0 123\") == 0\n    assert candidate(s = \"   +123\") == 123\n    assert candidate(s = \"     +42\") == 42\n    assert candidate(s = \"   +12345\") == 12345\n    assert candidate(s = \"    +42\") == 42\n    assert candidate(s = \"0000000000000\") == 0\n    assert candidate(s = \"     \") == 0\n    assert candidate(s = \"00000000000000\") == 0\n    assert candidate(s = \"   +42\") == 42\n    assert candidate(s = \"1337c0d3\") == 1337\n    assert candidate(s = \"   +0 91283472332 456\") == 0\n    assert candidate(s = \" 21474836460\") == 2147483647\n    assert candidate(s = \"+\") == 0\n    assert candidate(s = \"    -00130\") == -130\n    assert candidate(s = \"00000000000123456789\") == 123456789\n    assert candidate(s = \"  -0012a42\") == -12\n    assert candidate(s = \"  +3.14\") == 3\n    assert candidate(s = \"21474836478\") == 2147483647\n    assert candidate(s = \"-2147483648\") == -2147483648\n    assert candidate(s = \"-21474836489\") == -2147483648\n    assert candidate(s = \"  +  413\") == 0\n    assert candidate(s = \"    -2147483649\") == -2147483648\n    assert candidate(s = \"    21474836470000000000000000\") == 2147483647\n    assert candidate(s = \"    9223372036854775808\") == 2147483647\n    assert candidate(s = \"   2147483647abc\") == 2147483647\n    assert candidate(s = \"    -123 456\") == -123\n    assert candidate(s = \"    0000123\") == 123\n    assert candidate(s = \"    21474836470000000000000000000000\") == 2147483647\n    assert candidate(s = \"    2147483647000000000000000\") == 2147483647\n    assert candidate(s = \"   2147483647 -\") == 2147483647\n    assert candidate(s = \"    214748364700000000000000000000\") == 2147483647\n    assert candidate(s = \"   abcdefghijklmnopqrstuvwxyz\") == 0\n    assert candidate(s = \"    21474836470000000000000000000\") == 2147483647\n    assert candidate(s = \"    000000000000000000000000000000000000000000000000000   -123\") == 0\n    assert candidate(s = \"    +2147483649\") == 2147483647\n    assert candidate(s = \"   +0\") == 0\n    assert candidate(s = \"   2147483648\") == 2147483647\n    assert candidate(s = \"    2147483647000000000000000000000\") == 2147483647\n    assert candidate(s = \"    -21474836480000\") == -2147483648\n    assert candidate(s = \"    -214748364800000000000000000\") == -2147483648\n    assert candidate(s = \"    9223372036854775807\") == 2147483647\n    assert candidate(s = \"    -214748364800000\") == -2147483648\n    assert candidate(s = \"    -21474836480000000000000000000000\") == -2147483648\n    assert candidate(s = \"    -21474836480000000\") == -2147483648\n    assert candidate(s = \"   -12345678901234567890123456789012345678901234567890\") == -2147483648\n    assert candidate(s = \"    -214748364800\") == -2147483648\n    assert candidate(s = \"    2147483647000000000000000000000000000\") == 2147483647\n    assert candidate(s = \"  0000000000000   +123abc\") == 0\n    assert candidate(s = \"    -214748364800000000\") == -2147483648\n    assert candidate(s = \"    -21474836480000000000000000000000000000\") == -2147483648\n    assert candidate(s = \"    21474836470000000\") == 2147483647\n    assert candidate(s = \"   +000000000000000000000000000000123\") == 123\n    assert candidate(s = \"    2147483647000000000000000000000000\") == 2147483647\n    assert candidate(s = \"   -0000000000000000000000000000000000000000000000000000000000000001\") == -1\n    assert candidate(s = \"    000000000000000000000000000000000000000000000000000   123\") == 0\n    assert candidate(s = \"    -21474836480\") == -2147483648\n    assert candidate(s = \"    -2147483648000000000000\") == -2147483648\n    assert candidate(s = \"   -2147483648 0\") == -2147483648\n    assert candidate(s = \"    -214748364800000000000000000000\") == -2147483648\n    assert candidate(s = \"    -214748364800000000000000000000000000\") == -2147483648\n    assert candidate(s = \"    -9223372036854775808\") == -2147483648\n    assert candidate(s = \"    -214748364800000000000000000000000000000\") == -2147483648\n    assert candidate(s = \"    21474836470000000000000000000000000\") == 2147483647\n    assert candidate(s = \"    -2147483648000\") == -2147483648\n    assert candidate(s = \"    -2147483648\") == -2147483648\n    assert candidate(s = \"   -2147483648extra\") == -2147483648\n    assert candidate(s = \"    -2147483648000000000000000000000000\") == -2147483648\n    assert candidate(s = \"    214748364700000000000\") == 2147483647\n    assert candidate(s = \"   +2147483647extra\") == 2147483647\n    assert candidate(s = \"   -2147483648abc\") == -2147483648\n    assert candidate(s = \"   -2147483648\") == -2147483648\n    assert candidate(s = \"    214748364700000000000000000000000\") == 2147483647\n    assert candidate(s = \"   +000\") == 0\n    assert candidate(s = \"    -9223372036854775809\") == -2147483648\n    assert candidate(s = \"    214748364700000000000000\") == 2147483647\n    assert candidate(s = \" 0000000000000000000000000000000000000000000000000001\") == 1\n    assert candidate(s = \"   -0\") == 0\n    assert candidate(s = \"   +0000000000000000000000000000000000000000000000000000000000000001\") == 1\n    assert candidate(s = \"    010\") == 10\n    assert candidate(s = \"    2147483647000000\") == 2147483647\n    assert candidate(s = \"    -21474836480000000000000000000\") == -2147483648\n    assert candidate(s = \"000000000000000000000000000000000000000000000000000\") == 0\n    assert candidate(s = \"    -2147483648000000000000000\") == -2147483648\n    assert candidate(s = \"-0000000000000000000000000000000000000000000000000001\") == -1\n    assert candidate(s = \"    -2147483648000000000000000000\") == -2147483648\n    assert candidate(s = \"    2147483646\") == 2147483646\n    assert candidate(s = \"    214748364700000000000000000000000000000\") == 2147483647\n    assert candidate(s = \"    2147483647000\") == 2147483647\n    assert candidate(s = \"   12345678901234567890123456789012345678901234567890\") == 2147483647\n    assert candidate(s = \"    0000-123\") == 0\n    assert candidate(s = \"   -2147483648 -\") == -2147483648\n    assert candidate(s = \"    000000000000000000000000000000000000000000000000000   +123\") == 0\n    assert candidate(s = \"    123 456\") == 123\n    assert candidate(s = \"   +2147483647 0\") == 2147483647\n    assert candidate(s = \"    2147483648\") == 2147483647\n    assert candidate(s = \"   2147483647extra\") == 2147483647\n    assert candidate(s = \"    2147483647000000000000\") == 2147483647\n    assert candidate(s = \"    214748364700000000000000000\") == 2147483647\n    assert candidate(s = \"    21474836470000\") == 2147483647\n    assert candidate(s = \"   0000000000000000000000000000000000000000000000000000000000000000+1\") == 0\n    assert candidate(s = \"    -214748364800000000000000\") == -2147483648\n    assert candidate(s = \"    -2147483648000000\") == -2147483648\n    assert candidate(s = \"    -2147483648000000000000000000000\") == -2147483648\n    assert candidate(s = \"   -000000000000000000000000000000123\") == -123\n    assert candidate(s = \"    +2147483648\") == 2147483647\n    assert candidate(s = \"    214748364700\") == 2147483647\n    assert candidate(s = \"   +2147483647 +\") == 2147483647\n    assert candidate(s = \"   00000000000000000000000000000000000000000000000000000000000000001\") == 1\n    assert candidate(s = \"   +1234567890123456789012345678901234567890\") == 2147483647\n    assert candidate(s = \"    -214748364800000000000000000000000\") == -2147483648\n    assert candidate(s = \"    -2147483648000000000\") == -2147483648\n    assert candidate(s = \"   !@#$%^&*()_+\") == 0\n    assert candidate(s = \"    0000+123\") == 0\n    assert candidate(s = \"    -21474836480000000000\") == -2147483648\n    assert candidate(s = \"   -1234567890123456789012345678901234567890\") == -2147483648\n    assert candidate(s = \"    -2147483646\") == -2147483646\n    assert candidate(s = \"    -21474836480000000000000000000000000\") == -2147483648\n    assert candidate(s = \"    2147483647\") == 2147483647\n    assert candidate(s = \"    214748364700000000000000000000000000\") == 2147483647\n    assert candidate(s = \"    -214748364800000000000\") == -2147483648\n    assert candidate(s = \"   +2147483647abc\") == 2147483647\n    assert candidate(s = \"    21474836470\") == 2147483647\n    assert candidate(s = \"  0000000000000   123abc\") == 0\n    assert candidate(s = \"    21474836470000000000\") == 2147483647\n    assert candidate(s = \"    +123 456\") == 123\n    assert candidate(s = \"    2147483647000000000000000000\") == 2147483647\n    assert candidate(s = \"   0000000000000000000000000000000000000000000000000000000000000000-1\") == 0\n    assert candidate(s = \"   ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 0\n    assert candidate(s = \"    -2147483648000000000000000000000000000\") == -2147483648\n    assert candidate(s = \"   -2147483649\") == -2147483648\n    assert candidate(s = \"-+12\") == 0\n    assert candidate(s = \"    +2147483647\") == 2147483647\n    assert candidate(s = \"    18446744073709551616\") == 2147483647\n    assert candidate(s = \"   +0000000000000000000000000000000000000000000123\") == 123\n    assert candidate(s = \"   00000000000000000000000000000000000000000000000000000000000000000\") == 0\n    assert candidate(s = \"    21474836470000000000000\") == 2147483647\n    assert candidate(s = \"    214748364700000\") == 2147483647\n    assert candidate(s = \"    2147483647000000000\") == 2147483647\n    assert candidate(s = \"  0000000000000   -123abc\") == 0\n    assert candidate(s = \"  0000000000000   -00001\") == 0\n    assert candidate(s = \"   -000\") == 0\n    assert candidate(s = \"    214748364700000000\") == 2147483647\n    assert candidate(s = \"    -2147483647\") == -2147483647\n    assert candidate(s = \"    21474836470000000000000000000000000000\") == 2147483647\n    assert candidate(s = \"    -21474836480000000000000\") == -2147483648\n    assert candidate(s = \"    -21474836480000000000000000\") == -2147483648\n    assert candidate(s = \"   -2147483648 +\") == -2147483648\n    assert candidate(s = \"  0000000000000   +00001\") == 0\n    assert candidate(s = \"   2147483647\") == 2147483647\n", "input_output": [{"input": "s = \"2147483647\"", "output": "2147483647"}, {"input": "s = \"42 with words\"", "output": "42"}, {"input": "s = \"20000000000000000000000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"   \"+-12\"", "output": "Error: Solution.myAtoi() missing 1 required positional argument: 's'"}, {"input": "s = \"-2147483649\"", "output": "-2147483648"}, {"input": "s = \"-21474836480\"", "output": "-2147483648"}, {"input": "s = \"  000000000000   \"", "output": "0"}, {"input": "s = \"+1\"", "output": "1"}, {"input": "s = \"   -  42\"", "output": "0"}, {"input": "s = \"words with 42\"", "output": "0"}, {"input": "s = \"   -042\"", "output": "-42"}, {"input": "s = \"0-1\"", "output": "0"}, {"input": "s = \"   0\"", "output": "0"}, {"input": "s = \"-5\"", "output": "-5"}, {"input": "s = \"      -119197303367810844   \"", "output": "-2147483648"}, {"input": "s = \"   -12345\"", "output": "-12345"}, {"input": "s = \" \"", "output": "0"}, {"input": "s = \" -042\"", "output": "-42"}, {"input": "s = \"    -88827   5655  U\"", "output": "-88827"}, {"input": "s = \"+-12\"", "output": "0"}, {"input": "s = \"   +0 123\"", "output": "0"}, {"input": "s = \"+2\"", "output": "2"}, {"input": "s = \"   +0 91283472332\"", "output": "0"}, {"input": "s = \"   \"+\"", "output": "Error: Solution.myAtoi() missing 1 required positional argument: 's'"}, {"input": "s = \"   - 42\"", "output": "0"}, {"input": "s = \"words and 987\"", "output": "0"}, {"input": "s = \"3.14159\"", "output": "3"}, {"input": "s = \"   20000000000000000000\"", "output": "2147483647"}, {"input": "s = \"0000000000012345678\"", "output": "12345678"}, {"input": "s = \".\"", "output": "0"}, {"input": "s = \"2147483648\"", "output": "2147483647"}, {"input": "s = \"\"", "output": "0"}, {"input": "s = \"    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"", "output": "0"}, {"input": "s = \"-\"", "output": "0"}, {"input": "s = \"42\"", "output": "42"}, {"input": "s = \"-91283472332\"", "output": "-2147483648"}, {"input": "s = \"4193 with words\"", "output": "4193"}, {"input": "s = \"   3.14159\"", "output": "3"}, {"input": "s = \"  +0 123\"", "output": "0"}, {"input": "s = \"   +123\"", "output": "123"}, {"input": "s = \"     +42\"", "output": "42"}, {"input": "s = \"   +12345\"", "output": "12345"}, {"input": "s = \"    +42\"", "output": "42"}, {"input": "s = \"0000000000000\"", "output": "0"}, {"input": "s = \"     \"", "output": "0"}, {"input": "s = \"00000000000000\"", "output": "0"}, {"input": "s = \"   +42\"", "output": "42"}, {"input": "s = \"1337c0d3\"", "output": "1337"}, {"input": "s = \"   +0 91283472332 456\"", "output": "0"}, {"input": "s = \" 21474836460\"", "output": "2147483647"}, {"input": "s = \"+\"", "output": "0"}, {"input": "s = \"    -00130\"", "output": "-130"}, {"input": "s = \"00000000000123456789\"", "output": "123456789"}, {"input": "s = \"  -0012a42\"", "output": "-12"}, {"input": "s = \"  +3.14\"", "output": "3"}, {"input": "s = \"21474836478\"", "output": "2147483647"}, {"input": "s = \"-2147483648\"", "output": "-2147483648"}, {"input": "s = \"-21474836489\"", "output": "-2147483648"}, {"input": "s = \"  +  413\"", "output": "0"}, {"input": "s = \"    -2147483649\"", "output": "-2147483648"}, {"input": "s = \"    21474836470000000000000000\"", "output": "2147483647"}, {"input": "s = \"    9223372036854775808\"", "output": "2147483647"}, {"input": "s = \"   2147483647abc\"", "output": "2147483647"}, {"input": "s = \"    -123 456\"", "output": "-123"}, {"input": "s = \"    0000123\"", "output": "123"}, {"input": "s = \"    21474836470000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"    2147483647000000000000000\"", "output": "2147483647"}, {"input": "s = \"   2147483647 -\"", "output": "2147483647"}, {"input": "s = \"    214748364700000000000000000000\"", "output": "2147483647"}, {"input": "s = \"   abcdefghijklmnopqrstuvwxyz\"", "output": "0"}, {"input": "s = \"    21474836470000000000000000000\"", "output": "2147483647"}, {"input": "s = \"    000000000000000000000000000000000000000000000000000   -123\"", "output": "0"}, {"input": "s = \"    +2147483649\"", "output": "2147483647"}, {"input": "s = \"   +0\"", "output": "0"}, {"input": "s = \"   2147483648\"", "output": "2147483647"}, {"input": "s = \"    2147483647000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"   ~`-=\\|}{[]:;'\",.<>?/\"", "output": "Error: Solution.myAtoi() missing 1 required positional argument: 's'"}, {"input": "s = \"    -21474836480000\"", "output": "-2147483648"}, {"input": "s = \"    -214748364800000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    9223372036854775807\"", "output": "2147483647"}, {"input": "s = \"    -214748364800000\"", "output": "-2147483648"}, {"input": "s = \"    -21474836480000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    -21474836480000000\"", "output": "-2147483648"}, {"input": "s = \"   -12345678901234567890123456789012345678901234567890\"", "output": "-2147483648"}, {"input": "s = \"    -214748364800\"", "output": "-2147483648"}, {"input": "s = \"    2147483647000000000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"  0000000000000   +123abc\"", "output": "0"}, {"input": "s = \"    -214748364800000000\"", "output": "-2147483648"}, {"input": "s = \"    -21474836480000000000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    21474836470000000\"", "output": "2147483647"}, {"input": "s = \"   +000000000000000000000000000000123\"", "output": "123"}, {"input": "s = \"    2147483647000000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"   -0000000000000000000000000000000000000000000000000000000000000001\"", "output": "-1"}, {"input": "s = \"    000000000000000000000000000000000000000000000000000   123\"", "output": "0"}, {"input": "s = \"    -21474836480\"", "output": "-2147483648"}, {"input": "s = \"    -2147483648000000000000\"", "output": "-2147483648"}, {"input": "s = \"   -2147483648 0\"", "output": "-2147483648"}, {"input": "s = \"    -214748364800000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    -214748364800000000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    -9223372036854775808\"", "output": "-2147483648"}, {"input": "s = \"    -214748364800000000000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    21474836470000000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"    -2147483648000\"", "output": "-2147483648"}, {"input": "s = \"    -2147483648\"", "output": "-2147483648"}, {"input": "s = \"   -2147483648extra\"", "output": "-2147483648"}, {"input": "s = \"    -2147483648000000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    214748364700000000000\"", "output": "2147483647"}, {"input": "s = \"   +2147483647extra\"", "output": "2147483647"}, {"input": "s = \"   -2147483648abc\"", "output": "-2147483648"}, {"input": "s = \"   -2147483648\"", "output": "-2147483648"}, {"input": "s = \"    214748364700000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"   +000\"", "output": "0"}, {"input": "s = \"    -9223372036854775809\"", "output": "-2147483648"}, {"input": "s = \"    214748364700000000000000\"", "output": "2147483647"}, {"input": "s = \" 0000000000000000000000000000000000000000000000000001\"", "output": "1"}, {"input": "s = \"   -0\"", "output": "0"}, {"input": "s = \"   +0000000000000000000000000000000000000000000000000000000000000001\"", "output": "1"}, {"input": "s = \"    010\"", "output": "10"}, {"input": "s = \"    2147483647000000\"", "output": "2147483647"}, {"input": "s = \"    -21474836480000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"000000000000000000000000000000000000000000000000000\"", "output": "0"}, {"input": "s = \"    -2147483648000000000000000\"", "output": "-2147483648"}, {"input": "s = \"-0000000000000000000000000000000000000000000000000001\"", "output": "-1"}, {"input": "s = \"    -2147483648000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    2147483646\"", "output": "2147483646"}, {"input": "s = \"    214748364700000000000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"    2147483647000\"", "output": "2147483647"}, {"input": "s = \"   12345678901234567890123456789012345678901234567890\"", "output": "2147483647"}, {"input": "s = \"    0000-123\"", "output": "0"}, {"input": "s = \"   -2147483648 -\"", "output": "-2147483648"}, {"input": "s = \"    000000000000000000000000000000000000000000000000000   +123\"", "output": "0"}, {"input": "s = \"    123 456\"", "output": "123"}, {"input": "s = \"   +2147483647 0\"", "output": "2147483647"}, {"input": "s = \"    2147483648\"", "output": "2147483647"}, {"input": "s = \"   2147483647extra\"", "output": "2147483647"}, {"input": "s = \"    2147483647000000000000\"", "output": "2147483647"}, {"input": "s = \"    214748364700000000000000000\"", "output": "2147483647"}, {"input": "s = \"    21474836470000\"", "output": "2147483647"}, {"input": "s = \"   0000000000000000000000000000000000000000000000000000000000000000+1\"", "output": "0"}, {"input": "s = \"    -214748364800000000000000\"", "output": "-2147483648"}, {"input": "s = \"    -2147483648000000\"", "output": "-2147483648"}, {"input": "s = \"    -2147483648000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"   -000000000000000000000000000000123\"", "output": "-123"}, {"input": "s = \"    +2147483648\"", "output": "2147483647"}, {"input": "s = \"    214748364700\"", "output": "2147483647"}, {"input": "s = \"   +2147483647 +\"", "output": "2147483647"}, {"input": "s = \"   00000000000000000000000000000000000000000000000000000000000000001\"", "output": "1"}, {"input": "s = \"   +1234567890123456789012345678901234567890\"", "output": "2147483647"}, {"input": "s = \"    -214748364800000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    -2147483648000000000\"", "output": "-2147483648"}, {"input": "s = \"   !@#$%^&*()_+\"", "output": "0"}, {"input": "s = \"    0000+123\"", "output": "0"}, {"input": "s = \"    -21474836480000000000\"", "output": "-2147483648"}, {"input": "s = \"   -1234567890123456789012345678901234567890\"", "output": "-2147483648"}, {"input": "s = \"    -2147483646\"", "output": "-2147483646"}, {"input": "s = \"    -21474836480000000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"    2147483647\"", "output": "2147483647"}, {"input": "s = \"    214748364700000000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"    -214748364800000000000\"", "output": "-2147483648"}, {"input": "s = \"   +2147483647abc\"", "output": "2147483647"}, {"input": "s = \"    21474836470\"", "output": "2147483647"}, {"input": "s = \"  0000000000000   123abc\"", "output": "0"}, {"input": "s = \"    21474836470000000000\"", "output": "2147483647"}, {"input": "s = \"    +123 456\"", "output": "123"}, {"input": "s = \"    2147483647000000000000000000\"", "output": "2147483647"}, {"input": "s = \"   0000000000000000000000000000000000000000000000000000000000000000-1\"", "output": "0"}, {"input": "s = \"   ABCDEFGHIJKLMNOPQRSTUVWXYZ\"", "output": "0"}, {"input": "s = \"    -2147483648000000000000000000000000000\"", "output": "-2147483648"}, {"input": "s = \"   -2147483649\"", "output": "-2147483648"}, {"input": "s = \"-+12\"", "output": "0"}, {"input": "s = \"    +2147483647\"", "output": "2147483647"}, {"input": "s = \"    18446744073709551616\"", "output": "2147483647"}, {"input": "s = \"   +0000000000000000000000000000000000000000000123\"", "output": "123"}, {"input": "s = \"   00000000000000000000000000000000000000000000000000000000000000000\"", "output": "0"}, {"input": "s = \"    21474836470000000000000\"", "output": "2147483647"}, {"input": "s = \"    214748364700000\"", "output": "2147483647"}, {"input": "s = \"    2147483647000000000\"", "output": "2147483647"}, {"input": "s = \"  0000000000000   -123abc\"", "output": "0"}, {"input": "s = \"  0000000000000   -00001\"", "output": "0"}, {"input": "s = \"   -000\"", "output": "0"}, {"input": "s = \"    214748364700000000\"", "output": "2147483647"}, {"input": "s = \"    -2147483647\"", "output": "-2147483647"}, {"input": "s = \"    21474836470000000000000000000000000000\"", "output": "2147483647"}, {"input": "s = \"    -21474836480000000000000\"", "output": "-2147483648"}, {"input": "s = \"    -21474836480000000000000000\"", "output": "-2147483648"}, {"input": "s = \"   -2147483648 +\"", "output": "-2147483648"}, {"input": "s = \"  0000000000000   +00001\"", "output": "0"}, {"input": "s = \"   2147483647\"", "output": "2147483647"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nImplement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\nThe algorithm for myAtoi(string s) is as follows:\n\nWhitespace: Ignore any leading whitespace (\" \").\nSignedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.\nConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\nRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\n\nReturn the integer as the final result.\n \nExample 1:\n\nInput: s = \"42\"\nOutput: 42\nExplanation:\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\n\n\nExample 2:\n\nInput: s = \" -042\"\nOutput: -42\nExplanation:\n\nStep 1: \"   -042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -042\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\nExample 3:\n\nInput: s = \"1337c0d3\"\nOutput: 1337\nExplanation:\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\nExample 4:\n\nInput: s = \"0-1\"\nOutput: 0\nExplanation:\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\nExample 5:\n\nInput: s = \"words and 987\"\nOutput: 0\nExplanation:\nReading stops at the first non-digit character 'w'.\n\n \nConstraints:\n\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # Step 1: Ignore leading whitespace\n        s = s.lstrip()\n        \n        # Step 2: Check if the string is empty after stripping whitespace\n        if not s:\n            return 0\n        \n        # Step 3: Determine the sign\n        sign = 1\n        if s[0] == '-':\n            sign = -1\n            s = s[1:]\n        elif s[0] == '+':\n            s = s[1:]\n        \n        # Step 4: Read in the digits until a non-digit is encountered\n        result = 0\n        for char in s:\n            if char.isdigit():\n                result = result * 10 + int(char)\n            else:\n                break\n        \n        # Step 5: Apply the sign\n        result *= sign\n        \n        # Step 6: Clamp the result to the 32-bit signed integer range\n        INT_MIN = -2**31\n        INT_MAX = 2**31 - 1\n        if result < INT_MIN:\n            return INT_MIN\n        elif result > INT_MAX:\n            return INT_MAX\n        else:\n            return result\n```\n\nThis implementation follows the problem's specification and handles all the given examples and constraints. It first removes leading whitespace, checks for a sign, reads digits, applies the sign, and finally clamps the result to the 32-bit signed integer range."}
{"task_id": "palindrome-number", "question_id": 9, "difficulty": "Easy", "tags": ["Math"], "problem_description": "Given an integer x, return true if x is a palindrome, and false otherwise.\n \nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n \nConstraints:\n\n-231 <= x <= 231 - 1\n\n \nFollow up: Could you solve it without converting the integer to a string?", "starter_code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x and x % 10 == 0):\n            return False\n        y = 0\n        while y < x:\n            y = y * 10 + x % 10\n            x //= 10\n        return x in (y, y // 10)\n", "entry_point": "Solution().isPalindrome", "test": "def check(candidate):\n    assert candidate(x = 1221) == True\n    assert candidate(x = 10) == False\n    assert candidate(x = 123421) == False\n    assert candidate(x = 1) == True\n    assert candidate(x = -121) == False\n    assert candidate(x = 12345678987654321) == True\n    assert candidate(x = 123456) == False\n    assert candidate(x = -2147483648) == False\n    assert candidate(x = 1000000001) == True\n    assert candidate(x = 1111111111) == True\n    assert candidate(x = 0) == True\n    assert candidate(x = 123321) == True\n    assert candidate(x = 2147483647) == False\n    assert candidate(x = 1000021) == False\n    assert candidate(x = -1000021) == False\n    assert candidate(x = 12321) == True\n    assert candidate(x = 1234321) == True\n    assert candidate(x = -12321) == False\n    assert candidate(x = 121) == True\n    assert candidate(x = -1221) == False\n    assert candidate(x = 999999999999999999) == True\n    assert candidate(x = 123456789987654321) == True\n    assert candidate(x = 10000000000000000000000000000000000001) == True\n    assert candidate(x = 1100110011) == True\n    assert candidate(x = 12210000221) == False\n    assert candidate(x = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) == False\n    assert candidate(x = 12345678987654322) == False\n    assert candidate(x = 987656789) == True\n    assert candidate(x = 100000000000000001) == True\n    assert candidate(x = 1234567890987654321) == True\n    assert candidate(x = 100000000000000000001) == True\n    assert candidate(x = 101010101) == True\n    assert candidate(x = 1001001) == True\n    assert candidate(x = 12300321) == True\n    assert candidate(x = 2147447412) == True\n    assert candidate(x = 12345677654321) == True\n    assert candidate(x = 98765432112345678) == False\n    assert candidate(x = 10000000001) == True\n    assert candidate(x = 10000000000000000000) == False\n    assert candidate(x = 12345654321) == True\n    assert candidate(x = 999999999) == True\n    assert candidate(x = 987898789) == True\n    assert candidate(x = 1000000000000000000000000000000000001) == True\n    assert candidate(x = -1000000001) == False\n    assert candidate(x = 1000000000000000001) == True\n    assert candidate(x = 2121212121) == False\n    assert candidate(x = 123321000) == False\n    assert candidate(x = 1001) == True\n    assert candidate(x = 1234567899876543210) == False\n    assert candidate(x = 1230321) == True\n    assert candidate(x = 12211221) == True\n    assert candidate(x = 1002001) == True\n    assert candidate(x = 10000200001) == True\n    assert candidate(x = 98789) == True\n    assert candidate(x = 123454321) == True\n    assert candidate(x = 98765432123456789) == True\n    assert candidate(x = 100000000000000000000000000000000000000000000000001) == True\n    assert candidate(x = 100000000000000000000000000000000000000) == False\n    assert candidate(x = 123321123321) == True\n    assert candidate(x = 1111111111111111111) == True\n    assert candidate(x = 1000000000) == False\n", "input_output": [{"input": "x = 1221", "output": "True"}, {"input": "x = 10", "output": "False"}, {"input": "x = 123421", "output": "False"}, {"input": "x = 1", "output": "True"}, {"input": "x = -121", "output": "False"}, {"input": "x = 12345678987654321", "output": "True"}, {"input": "x = 123456", "output": "False"}, {"input": "x = -2147483648", "output": "False"}, {"input": "x = 1000000001", "output": "True"}, {"input": "x = 1111111111", "output": "True"}, {"input": "x = 0", "output": "True"}, {"input": "x = 123321", "output": "True"}, {"input": "x = 2147483647", "output": "False"}, {"input": "x = 1000021", "output": "False"}, {"input": "x = -1000021", "output": "False"}, {"input": "x = 12321", "output": "True"}, {"input": "x = 1234321", "output": "True"}, {"input": "x = -12321", "output": "False"}, {"input": "x = 121", "output": "True"}, {"input": "x = -1221", "output": "False"}, {"input": "x = 999999999999999999", "output": "True"}, {"input": "x = 123456789987654321", "output": "True"}, {"input": "x = 10000000000000000000000000000000000001", "output": "True"}, {"input": "x = 1100110011", "output": "True"}, {"input": "x = 12210000221", "output": "False"}, {"input": "x = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "output": "False"}, {"input": "x = 12345678987654322", "output": "False"}, {"input": "x = 987656789", "output": "True"}, {"input": "x = 100000000000000001", "output": "True"}, {"input": "x = 1234567890987654321", "output": "True"}, {"input": "x = 100000000000000000001", "output": "True"}, {"input": "x = 101010101", "output": "True"}, {"input": "x = 1001001", "output": "True"}, {"input": "x = 12300321", "output": "True"}, {"input": "x = 2147447412", "output": "True"}, {"input": "x = 12345677654321", "output": "True"}, {"input": "x = 98765432112345678", "output": "False"}, {"input": "x = 10000000001", "output": "True"}, {"input": "x = 10000000000000000000", "output": "False"}, {"input": "x = 12345654321", "output": "True"}, {"input": "x = 999999999", "output": "True"}, {"input": "x = 987898789", "output": "True"}, {"input": "x = 1000000000000000000000000000000000001", "output": "True"}, {"input": "x = -1000000001", "output": "False"}, {"input": "x = 1000000000000000001", "output": "True"}, {"input": "x = 2121212121", "output": "False"}, {"input": "x = 123321000", "output": "False"}, {"input": "x = 1001", "output": "True"}, {"input": "x = 1234567899876543210", "output": "False"}, {"input": "x = 1230321", "output": "True"}, {"input": "x = 12211221", "output": "True"}, {"input": "x = 1002001", "output": "True"}, {"input": "x = 10000200001", "output": "True"}, {"input": "x = 98789", "output": "True"}, {"input": "x = 123454321", "output": "True"}, {"input": "x = 98765432123456789", "output": "True"}, {"input": "x = 100000000000000000000000000000000000000000000000001", "output": "True"}, {"input": "x = 100000000000000000000000000000000000000", "output": "False"}, {"input": "x = 123321123321", "output": "True"}, {"input": "x = 1111111111111111111", "output": "True"}, {"input": "x = 1000000000", "output": "False"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an integer x, return true if x is a palindrome, and false otherwise.\n \nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n \nConstraints:\n\n-231 <= x <= 231 - 1\n\n \nFollow up: Could you solve it without converting the integer to a string?\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # Negative numbers are not palindromes\n        if x < 0:\n            return False\n        \n        # Initialize variables to store the original and reversed numbers\n        original = x\n        reversed_num = 0\n        \n        # Reverse the number\n        while x > 0:\n            digit = x % 10\n            reversed_num = reversed_num * 10 + digit\n            x //= 10\n        \n        # Check if the original number is equal to the reversed number\n        return original == reversed_num\n```"}
{"task_id": "regular-expression-matching", "question_id": 10, "difficulty": "Hard", "tags": ["Recursion", "String", "Dynamic Programming"], "problem_description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n \nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n \nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\n\n", "starter_code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ", "estimated_date": "2015-08-07", "prompt": "import random\nimport functools\nimport collections\nimport string\nimport math\nimport datetime\n\nfrom typing import *\nfrom functools import *\nfrom collections import *\nfrom itertools import *\nfrom heapq import *\nfrom bisect import *\nfrom string import *\nfrom operator import *\nfrom math import *\n\ninf = float('inf')\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef list_node(values: list):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    p = head\n    for val in values[1:]:\n        node = ListNode(val)\n        p.next = node\n        p = node\n    return head\n\ndef is_same_list(p1, p2):\n    if p1 is None and p2 is None:\n        return True\n    if not p1 or not p2:\n        return False\n    return p1.val == p2.val and is_same_list(p1.next, p2.next)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_node(values: list):\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    i = 1\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n    else:\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n", "completion": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        @cache\n        def dfs(i, j):\n            if j >= n:\n                return i == m\n            if j + 1 < n and p[j + 1] == '*':\n                return dfs(i, j + 2) or (\n                    i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j)\n                )\n            return i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j + 1)\n\n        m, n = len(s), len(p)\n        return dfs(0, 0)\n", "entry_point": "Solution().isMatch", "test": "def check(candidate):\n    assert candidate(s = \"aa\",p = \"a*\") == True\n    assert candidate(s = \"aab\",p = \"c*a*b\") == True\n    assert candidate(s = \"ab\",p = \".*\") == True\n    assert candidate(s = \"aa\",p = \"a\") == False\n    assert candidate(s = \"mississippi\",p = \"mis*is*p*.\") == False\n    assert candidate(s = \"aabbccddeeff\",p = \"a*b*c*d*e*f*f*\") == True\n    assert candidate(s = \"abababa\",p = \"(ab)*a\") == False\n    assert candidate(s = \"abcde\",p = \"a*.*e\") == True\n    assert candidate(s = \"ababcd\",p = \"a.*a.*d\") == True\n    assert candidate(s = \"aabbbbc\",p = \"a*b*c\") == True\n    assert candidate(s = \"aaaaaa\",p = \"a*a*a*a*a*a\") == True\n    assert candidate(s = \"aabb\",p = \"ab*a*b*\") == True\n    assert candidate(s = \"abcccccaaaa\",p = \"ab*c*a*.*\") == True\n    assert candidate(s = \"abcdef\",p = \"abc.*f\") == True\n    assert candidate(s = \"ababab\",p = \"(ab)*\") == False\n    assert candidate(s = \"ab\",p = \"a*b*c*d*.*e*\") == True\n    assert candidate(s = \"xaymz\",p = \"x.*z\") == True\n    assert candidate(s = \"xaybz\",p = \"xa*y*b*z\") == True\n    assert candidate(s = \"abcdefgh\",p = \"a*d*fh\") == False\n    assert candidate(s = \"aaa\",p = \"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a\") == True\n    assert candidate(s = \"mississippi\",p = \"mi*ss*is*si*p*i*\") == True\n    assert candidate(s = \"zzzz\",p = \"z*\") == True\n    assert candidate(s = \"abcdefgh\",p = \"a.h\") == False\n    assert candidate(s = \"ababab\",p = \"(ab)*b*\") == False\n    assert candidate(s = \"abcdefgh\",p = \"a.*h\") == True\n    assert candidate(s = \"mississippi\",p = \"mi.*is.*p*i\") == True\n    assert candidate(s = \"abcdefgh\",p = \"abcdefgh\") == True\n    assert candidate(s = \"abcdefg\",p = \"a*bc.d*efg\") == True\n    assert candidate(s = \"abcdefgh\",p = \"a*b*c*d*e*f*g*h\") == True\n    assert candidate(s = \"abcdefgh\",p = \"a*b*c*d*e*f*g*h*\") == True\n    assert candidate(s = \"abcd\",p = \"a.b.c.d\") == False\n    assert candidate(s = \"aabbcc\",p = \"a*b*c*c\") == True\n    assert candidate(s = \"abc\",p = \"abc.\") == False\n    assert candidate(s = \"mississippi\",p = \"m*is*i*s*i*p*i\") == True\n    assert candidate(s = \"mississippi\",p = \"m*i*ss*i*p*i*\") == False\n    assert candidate(s = \"abcde\",p = \"a.*de\") == True\n    assert candidate(s = \"abcdeabcde\",p = \"abc*de*abc*de*\") == True\n    assert candidate(s = \"abcd\",p = \"a*b*c*d*\") == True\n    assert candidate(s = \"abcde\",p = \"a*.b*c*e*\") == False\n    assert candidate(s = \"aabbbcccddd\",p = \"a*b*c*d*\") == True\n    assert candidate(s = \"abc\",p = \"a.b.c\") == False\n    assert candidate(s = \"abababab\",p = \"(ab)*\") == False\n    assert candidate(s = \"hello\",p = \"he*llo*\") == True\n    assert candidate(s = \"hello\",p = \"he.*o\") == True\n    assert candidate(s = \"abcd\",p = \"d*\") == False\n    assert candidate(s = \"abcde\",p = \"a..de\") == True\n    assert candidate(s = \"abcabcabcabc\",p = \"(abc)*d\") == False\n    assert candidate(s = \"abcdabcd\",p = \"abcd*\") == False\n    assert candidate(s = \"aabb\",p = \"aab*b*\") == True\n    assert candidate(s = \"xyzzy\",p = \"x*zy\") == False\n    assert candidate(s = \"abcd\",p = \"a.*d\") == True\n    assert candidate(s = \"xxyyzz\",p = \"x*y*z*\") == True\n    assert candidate(s = \"abc\",p = \"a.c\") == True\n    assert candidate(s = \"xyxxyxyx\",p = \"(xy)*x\") == False\n    assert candidate(s = \"aabbbccc\",p = \"a*b*c*\") == True\n    assert candidate(s = \"abcabcabcabc\",p = \"(abc)*\") == False\n    assert candidate(s = \"abcdef\",p = \"a*bcdef\") == True\n    assert candidate(s = \"aaaab\",p = \"a*b*\") == True\n    assert candidate(s = \"complex\",p = \"c*o*m*p*l*e*x*\") == True\n    assert candidate(s = \"aaa\",p = \"a*a\") == True\n    assert candidate(s = \"xyz\",p = \"x*y*z*\") == True\n    assert candidate(s = \"abcdefgh\",p = \"a.*g\") == False\n    assert candidate(s = \"abcde\",p = \"a*b.c*d*e*\") == True\n    assert candidate(s = \"abcde\",p = \"a*b*c*d*e*\") == True\n    assert candidate(s = \"zzzzzzzzzzzz\",p = \"z*z*z*z*z*z*z*z*z*z*z*z*z*z*z*z*z*\") == True\n    assert candidate(s = \"aabbccddeeff\",p = \"a*b*c*d*e*f*\") == True\n    assert candidate(s = \"hello\",p = \"he.*\") == True\n    assert candidate(s = \"abcde\",p = \"a*b*c*d.e\") == False\n    assert candidate(s = \"aaaaabbb\",p = \"a*b*.*\") == True\n    assert candidate(s = \"aabbccddeeffgghh\",p = \"a*b*c*d*e*f*g*h*\") == True\n    assert candidate(s = \"abbabb\",p = \"a*b*b*\") == False\n    assert candidate(s = \"sequence\",p = \"s.e*q*u*e*n*c*e*\") == True\n    assert candidate(s = \"abcdabcd\",p = \"a*b*c*d*\") == False\n    assert candidate(s = \"abcdedef\",p = \"abcd*e*f*\") == False\n    assert candidate(s = \"abcdefgh\",p = \"a.b.c.d.e.f.g.h\") == False\n    assert candidate(s = \"mississippi\",p = \"mi.*.pi.*\") == True\n    assert candidate(s = \"hello\",p = \"he*ll*o\") == True\n    assert candidate(s = \"abcde\",p = \"a*bc.e*\") == True\n    assert candidate(s = \"aaaab\",p = \"a*a*a*a\") == False\n    assert candidate(s = \"abcde\",p = \"a.*e\") == True\n    assert candidate(s = \"aabbb\",p = \"a*b*b\") == True\n    assert candidate(s = \"regex\",p = \"r.e*g*e*x*\") == True\n    assert candidate(s = \"abcdef\",p = \"a*b*c*d*e*f*\") == True\n    assert candidate(s = \"aaaa\",p = \"a*a*a*a\") == True\n    assert candidate(s = \"teststring\",p = \"te*t*st*ring\") == False\n    assert candidate(s = \"abcde\",p = \"a*b*c*de\") == True\n    assert candidate(s = \"bbbac\",p = \"ba*ac\") == False\n    assert candidate(s = \"aabbccddeeffgg\",p = \"a*b*c*d*e*f*g*\") == True\n    assert candidate(s = \"abcde\",p = \"a*bc*de\") == True\n    assert candidate(s = \"xyxyxyxyxyx\",p = \"x.y.x.y.x.y.x.y.x.y.x\") == False\n    assert candidate(s = \"a\",p = \"a*a*a*a*\") == True\n    assert candidate(s = \"abababab\",p = \"a*b*a*b*a*b*a*b\") == True\n    assert candidate(s = \"abcdeabcdeabcde\",p = \"abc*de*abc*de*abc*de*f*\") == True\n    assert candidate(s = \"abbbba\",p = \"ab*ba\") == True\n    assert candidate(s = \"teststring\",p = \"t.*st.*r.*ing\") == True\n    assert candidate(s = \"abcabc\",p = \"abc*\") == False\n    assert candidate(s = \"abcd\",p = \"a*b*c*d*.*\") == True\n    assert candidate(s = \"zzzzzzzzzzzz\",p = \"z*\") == True\n    assert candidate(s = \"mississippi\",p = \"m.*s*is*p*i*.*\") == True\n    assert candidate(s = \"abcdefgh\",p = \".*\") == True\n    assert candidate(s = \"abcdefg\",p = \".*f.*\") == True\n    assert candidate(s = \"abccde\",p = \"abc*d*e\") == True\n    assert candidate(s = \"aabbbccdd\",p = \"aa*bbb*cc*dd*\") == True\n    assert candidate(s = \"foobar\",p = \"fo*oba*r\") == True\n    assert candidate(s = \"abcde\",p = \"a.*f\") == False\n    assert candidate(s = \"aabb\",p = \"a*b*b*a*\") == True\n    assert candidate(s = \"zabczabcz\",p = \"z*abc*z*\") == False\n    assert candidate(s = \"aaaabbbb\",p = \"a*b*b*\") == True\n    assert candidate(s = \"aabbcc\",p = \"a*b*b*c*c*\") == True\n    assert candidate(s = \"abc\",p = \"a*b*c*\") == True\n    assert candidate(s = \"abcdeabcdeabcde\",p = \"abc*de*abc*de*abc*de*\") == True\n    assert candidate(s = \"abcde\",p = \"a*c*e\") == False\n    assert candidate(s = \"xyzzaz\",p = \"x*y*.*z*\") == True\n    assert candidate(s = \"ababab\",p = \"(ab)*b\") == False\n    assert candidate(s = \"abcdef\",p = \"abc.def\") == False\n    assert candidate(s = \"xyx\",p = \"x*y*x*\") == True\n    assert candidate(s = \"aaaaaa\",p = \"a*a*a*a*\") == True\n    assert candidate(s = \"abbb\",p = \"ab*\") == True\n    assert candidate(s = \"a\",p = \".\") == True\n    assert candidate(s = \"abcdexyz\",p = \"abc.*xyz\") == True\n    assert candidate(s = \"aabbcc\",p = \"a*b*c*\") == True\n    assert candidate(s = \"leetcode\",p = \"le.*e.*tcode\") == True\n    assert candidate(s = \"aaa\",p = \"ab*a*c*a\") == True\n    assert candidate(s = \"abcd\",p = \"a.d\") == False\n    assert candidate(s = \"xylophone\",p = \"x.l*o.h.p*ne\") == True\n    assert candidate(s = \"abcde\",p = \".*\") == True\n    assert candidate(s = \"abxyzbcd\",p = \"ab.*bc*d\") == True\n    assert candidate(s = \"zzzzz\",p = \"z*\") == True\n    assert candidate(s = \"aaa\",p = \"a*a*\") == True\n    assert candidate(s = \"aaaaaaab\",p = \"a*a*a*a*a*a*a*b\") == True\n    assert candidate(s = \"hello world\",p = \"h.*o w*r*d\") == False\n    assert candidate(s = \"abcdefgh\",p = \"a.*b.*c.*d.*e.*f.*g.*h\") == True\n    assert candidate(s = \"hello\",p = \"h.l.o\") == True\n    assert candidate(s = \"abcd\",p = \"a.b*c.d\") == False\n    assert candidate(s = \"abcdefgh\",p = \"abcdefgh.\") == False\n    assert candidate(s = \"a\",p = \"ab*a\") == False\n    assert candidate(s = \"patternmatching\",p = \"pat*tern*m*atching*\") == True\n    assert candidate(s = \"abcabcabc\",p = \"(abc)*\") == False\n    assert candidate(s = \"ababab\",p = \"(ab)*ab*\") == False\n    assert candidate(s = \"abcd\",p = \"a.c*d*\") == True\n    assert candidate(s = \"a\",p = \".*\") == True\n    assert candidate(s = \"abcdef\",p = \"abcd.e*f\") == True\n    assert candidate(s = \"aabb\",p = \"a*bb\") == True\n    assert candidate(s = \"abcdefgh\",p = \"abcdefgh*\") == True\n    assert candidate(s = \"aaa\",p = \"a*a*a*a*a*a*\") == True\n    assert candidate(s = \"aaaaaa\",p = \"a*a*a*a*a*a*\") == True\n    assert candidate(s = \"abab\",p = \"(ab)*\") == False\n    assert candidate(s = \"mississippi\",p = \"mi*s*is*ip*pi*s*\") == True\n    assert candidate(s = \"aaaaab\",p = \"a*ba*\") == True\n    assert candidate(s = \"abc\",p = \".b.\") == True\n    assert candidate(s = \"abcd\",p = \"a*b.c*d*\") == True\n", "input_output": [{"input": "s = \"aa\", p = \"a*\"", "output": "True"}, {"input": "s = \"aab\", p = \"c*a*b\"", "output": "True"}, {"input": "s = \"ab\", p = \".*\"", "output": "True"}, {"input": "s = \"aa\", p = \"a\"", "output": "False"}, {"input": "s = \"mississippi\", p = \"mis*is*p*.\"", "output": "False"}, {"input": "s = \"aabbccddeeff\", p = \"a*b*c*d*e*f*f*\"", "output": "True"}, {"input": "s = \"abababa\", p = \"(ab)*a\"", "output": "False"}, {"input": "s = \"abcde\", p = \"a*.*e\"", "output": "True"}, {"input": "s = \"ababcd\", p = \"a.*a.*d\"", "output": "True"}, {"input": "s = \"aabbbbc\", p = \"a*b*c\"", "output": "True"}, {"input": "s = \"aaaaaa\", p = \"a*a*a*a*a*a\"", "output": "True"}, {"input": "s = \"aabb\", p = \"ab*a*b*\"", "output": "True"}, {"input": "s = \"abcccccaaaa\", p = \"ab*c*a*.*\"", "output": "True"}, {"input": "s = \"abcdef\", p = \"abc.*f\"", "output": "True"}, {"input": "s = \"ababab\", p = \"(ab)*\"", "output": "False"}, {"input": "s = \"ab\", p = \"a*b*c*d*.*e*\"", "output": "True"}, {"input": "s = \"xaymz\", p = \"x.*z\"", "output": "True"}, {"input": "s = \"xaybz\", p = \"xa*y*b*z\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \"a*d*fh\"", "output": "False"}, {"input": "s = \"aaa\", p = \"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a\"", "output": "True"}, {"input": "s = \"mississippi\", p = \"mi*ss*is*si*p*i*\"", "output": "True"}, {"input": "s = \"zzzz\", p = \"z*\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \"a.h\"", "output": "False"}, {"input": "s = \"ababab\", p = \"(ab)*b*\"", "output": "False"}, {"input": "s = \"abcdefgh\", p = \"a.*h\"", "output": "True"}, {"input": "s = \"mississippi\", p = \"mi.*is.*p*i\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \"abcdefgh\"", "output": "True"}, {"input": "s = \"abcdefg\", p = \"a*bc.d*efg\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \"a*b*c*d*e*f*g*h\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \"a*b*c*d*e*f*g*h*\"", "output": "True"}, {"input": "s = \"abcd\", p = \"a.b.c.d\"", "output": "False"}, {"input": "s = \"aabbcc\", p = \"a*b*c*c\"", "output": "True"}, {"input": "s = \"abc\", p = \"abc.\"", "output": "False"}, {"input": "s = \"mississippi\", p = \"m*is*i*s*i*p*i\"", "output": "True"}, {"input": "s = \"mississippi\", p = \"m*i*ss*i*p*i*\"", "output": "False"}, {"input": "s = \"abcde\", p = \"a.*de\"", "output": "True"}, {"input": "s = \"abcdeabcde\", p = \"abc*de*abc*de*\"", "output": "True"}, {"input": "s = \"abcd\", p = \"a*b*c*d*\"", "output": "True"}, {"input": "s = \"abcde\", p = \"a*.b*c*e*\"", "output": "False"}, {"input": "s = \"aabbbcccddd\", p = \"a*b*c*d*\"", "output": "True"}, {"input": "s = \"abc\", p = \"a.b.c\"", "output": "False"}, {"input": "s = \"abababab\", p = \"(ab)*\"", "output": "False"}, {"input": "s = \"hello\", p = \"he*llo*\"", "output": "True"}, {"input": "s = \"hello\", p = \"he.*o\"", "output": "True"}, {"input": "s = \"abcd\", p = \"d*\"", "output": "False"}, {"input": "s = \"abcde\", p = \"a..de\"", "output": "True"}, {"input": "s = \"abcabcabcabc\", p = \"(abc)*d\"", "output": "False"}, {"input": "s = \"abcdabcd\", p = \"abcd*\"", "output": "False"}, {"input": "s = \"aabb\", p = \"aab*b*\"", "output": "True"}, {"input": "s = \"xyzzy\", p = \"x*zy\"", "output": "False"}, {"input": "s = \"abcd\", p = \"a.*d\"", "output": "True"}, {"input": "s = \"xxyyzz\", p = \"x*y*z*\"", "output": "True"}, {"input": "s = \"abc\", p = \"a.c\"", "output": "True"}, {"input": "s = \"xyxxyxyx\", p = \"(xy)*x\"", "output": "False"}, {"input": "s = \"aabbbccc\", p = \"a*b*c*\"", "output": "True"}, {"input": "s = \"abcabcabcabc\", p = \"(abc)*\"", "output": "False"}, {"input": "s = \"abcdef\", p = \"a*bcdef\"", "output": "True"}, {"input": "s = \"aaaab\", p = \"a*b*\"", "output": "True"}, {"input": "s = \"complex\", p = \"c*o*m*p*l*e*x*\"", "output": "True"}, {"input": "s = \"aaa\", p = \"a*a\"", "output": "True"}, {"input": "s = \"xyz\", p = \"x*y*z*\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \"a.*g\"", "output": "False"}, {"input": "s = \"abcde\", p = \"a*b.c*d*e*\"", "output": "True"}, {"input": "s = \"abcde\", p = \"a*b*c*d*e*\"", "output": "True"}, {"input": "s = \"zzzzzzzzzzzz\", p = \"z*z*z*z*z*z*z*z*z*z*z*z*z*z*z*z*z*\"", "output": "True"}, {"input": "s = \"aabbccddeeff\", p = \"a*b*c*d*e*f*\"", "output": "True"}, {"input": "s = \"hello\", p = \"he.*\"", "output": "True"}, {"input": "s = \"abcde\", p = \"a*b*c*d.e\"", "output": "False"}, {"input": "s = \"aaaaabbb\", p = \"a*b*.*\"", "output": "True"}, {"input": "s = \"aabbccddeeffgghh\", p = \"a*b*c*d*e*f*g*h*\"", "output": "True"}, {"input": "s = \"abbabb\", p = \"a*b*b*\"", "output": "False"}, {"input": "s = \"sequence\", p = \"s.e*q*u*e*n*c*e*\"", "output": "True"}, {"input": "s = \"abcdabcd\", p = \"a*b*c*d*\"", "output": "False"}, {"input": "s = \"abcdedef\", p = \"abcd*e*f*\"", "output": "False"}, {"input": "s = \"abcdefgh\", p = \"a.b.c.d.e.f.g.h\"", "output": "False"}, {"input": "s = \"mississippi\", p = \"mi.*.pi.*\"", "output": "True"}, {"input": "s = \"hello\", p = \"he*ll*o\"", "output": "True"}, {"input": "s = \"abcde\", p = \"a*bc.e*\"", "output": "True"}, {"input": "s = \"aaaab\", p = \"a*a*a*a\"", "output": "False"}, {"input": "s = \"abcde\", p = \"a.*e\"", "output": "True"}, {"input": "s = \"aabbb\", p = \"a*b*b\"", "output": "True"}, {"input": "s = \"regex\", p = \"r.e*g*e*x*\"", "output": "True"}, {"input": "s = \"abcdef\", p = \"a*b*c*d*e*f*\"", "output": "True"}, {"input": "s = \"aaaa\", p = \"a*a*a*a\"", "output": "True"}, {"input": "s = \"teststring\", p = \"te*t*st*ring\"", "output": "False"}, {"input": "s = \"abcde\", p = \"a*b*c*de\"", "output": "True"}, {"input": "s = \"bbbac\", p = \"ba*ac\"", "output": "False"}, {"input": "s = \"aabbccddeeffgg\", p = \"a*b*c*d*e*f*g*\"", "output": "True"}, {"input": "s = \"abcde\", p = \"a*bc*de\"", "output": "True"}, {"input": "s = \"xyxyxyxyxyx\", p = \"x.y.x.y.x.y.x.y.x.y.x\"", "output": "False"}, {"input": "s = \"a\", p = \"a*a*a*a*\"", "output": "True"}, {"input": "s = \"abababab\", p = \"a*b*a*b*a*b*a*b\"", "output": "True"}, {"input": "s = \"abcdeabcdeabcde\", p = \"abc*de*abc*de*abc*de*f*\"", "output": "True"}, {"input": "s = \"abbbba\", p = \"ab*ba\"", "output": "True"}, {"input": "s = \"teststring\", p = \"t.*st.*r.*ing\"", "output": "True"}, {"input": "s = \"abcabc\", p = \"abc*\"", "output": "False"}, {"input": "s = \"abcd\", p = \"a*b*c*d*.*\"", "output": "True"}, {"input": "s = \"zzzzzzzzzzzz\", p = \"z*\"", "output": "True"}, {"input": "s = \"mississippi\", p = \"m.*s*is*p*i*.*\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \".*\"", "output": "True"}, {"input": "s = \"abcdefg\", p = \".*f.*\"", "output": "True"}, {"input": "s = \"abccde\", p = \"abc*d*e\"", "output": "True"}, {"input": "s = \"aabbbccdd\", p = \"aa*bbb*cc*dd*\"", "output": "True"}, {"input": "s = \"foobar\", p = \"fo*oba*r\"", "output": "True"}, {"input": "s = \"abcde\", p = \"a.*f\"", "output": "False"}, {"input": "s = \"aabb\", p = \"a*b*b*a*\"", "output": "True"}, {"input": "s = \"zabczabcz\", p = \"z*abc*z*\"", "output": "False"}, {"input": "s = \"aaaabbbb\", p = \"a*b*b*\"", "output": "True"}, {"input": "s = \"aabbcc\", p = \"a*b*b*c*c*\"", "output": "True"}, {"input": "s = \"abc\", p = \"a*b*c*\"", "output": "True"}, {"input": "s = \"abcdeabcdeabcde\", p = \"abc*de*abc*de*abc*de*\"", "output": "True"}, {"input": "s = \"abcde\", p = \"a*c*e\"", "output": "False"}, {"input": "s = \"xyzzaz\", p = \"x*y*.*z*\"", "output": "True"}, {"input": "s = \"ababab\", p = \"(ab)*b\"", "output": "False"}, {"input": "s = \"abcdef\", p = \"abc.def\"", "output": "False"}, {"input": "s = \"xyx\", p = \"x*y*x*\"", "output": "True"}, {"input": "s = \"aaaaaa\", p = \"a*a*a*a*\"", "output": "True"}, {"input": "s = \"abbb\", p = \"ab*\"", "output": "True"}, {"input": "s = \"a\", p = \".\"", "output": "True"}, {"input": "s = \"abcdexyz\", p = \"abc.*xyz\"", "output": "True"}, {"input": "s = \"aabbcc\", p = \"a*b*c*\"", "output": "True"}, {"input": "s = \"leetcode\", p = \"le.*e.*tcode\"", "output": "True"}, {"input": "s = \"aaa\", p = \"ab*a*c*a\"", "output": "True"}, {"input": "s = \"abcd\", p = \"a.d\"", "output": "False"}, {"input": "s = \"xylophone\", p = \"x.l*o.h.p*ne\"", "output": "True"}, {"input": "s = \"abcde\", p = \".*\"", "output": "True"}, {"input": "s = \"abxyzbcd\", p = \"ab.*bc*d\"", "output": "True"}, {"input": "s = \"zzzzz\", p = \"z*\"", "output": "True"}, {"input": "s = \"aaa\", p = \"a*a*\"", "output": "True"}, {"input": "s = \"aaaaaaab\", p = \"a*a*a*a*a*a*a*b\"", "output": "True"}, {"input": "s = \"hello world\", p = \"h.*o w*r*d\"", "output": "False"}, {"input": "s = \"abcdefgh\", p = \"a.*b.*c.*d.*e.*f.*g.*h\"", "output": "True"}, {"input": "s = \"hello\", p = \"h.l.o\"", "output": "True"}, {"input": "s = \"abcd\", p = \"a.b*c.d\"", "output": "False"}, {"input": "s = \"abcdefgh\", p = \"abcdefgh.\"", "output": "False"}, {"input": "s = \"a\", p = \"ab*a\"", "output": "False"}, {"input": "s = \"patternmatching\", p = \"pat*tern*m*atching*\"", "output": "True"}, {"input": "s = \"abcabcabc\", p = \"(abc)*\"", "output": "False"}, {"input": "s = \"ababab\", p = \"(ab)*ab*\"", "output": "False"}, {"input": "s = \"abcd\", p = \"a.c*d*\"", "output": "True"}, {"input": "s = \"a\", p = \".*\"", "output": "True"}, {"input": "s = \"abcdef\", p = \"abcd.e*f\"", "output": "True"}, {"input": "s = \"aabb\", p = \"a*bb\"", "output": "True"}, {"input": "s = \"abcdefgh\", p = \"abcdefgh*\"", "output": "True"}, {"input": "s = \"aaa\", p = \"a*a*a*a*a*a*\"", "output": "True"}, {"input": "s = \"aaaaaa\", p = \"a*a*a*a*a*a*\"", "output": "True"}, {"input": "s = \"abab\", p = \"(ab)*\"", "output": "False"}, {"input": "s = \"mississippi\", p = \"mi*s*is*ip*pi*s*\"", "output": "True"}, {"input": "s = \"aaaaab\", p = \"a*ba*\"", "output": "True"}, {"input": "s = \"abc\", p = \".b.\"", "output": "True"}, {"input": "s = \"abcd\", p = \"a*b.c*d*\"", "output": "True"}], "query": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n \nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n \nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \n```\n\n### Answer: (use the provided format with backticks)\n", "response": "```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # Dynamic programming table\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        # Empty pattern matches empty string\n        dp[-1][-1] = True\n        \n        # Fill the table from bottom-right to top-left\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                first_match = (i < len(s)) and p[j] in {s[i], '.'}\n                \n                if j+1 < len(p) and p[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or (first_match and dp[i+1][j])\n                else:\n                    dp[i][j] = first_match and dp[i+1][j+1]\n        \n        return dp[0][0]\n```\n\nThis solution uses dynamic programming to solve the problem of regular expression matching. The `dp` table is used to store whether the substring `s[i:]` matches the pattern `p[j:]`. The table is filled in a bottom-up manner, starting from the base case where an empty pattern matches an empty string. The solution handles the special characters `.` and `*` as specified in the problem statement."}
